<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/beige.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/magula.css">


  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);

  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <!-- Heading section -->
      <section data-markdown>
        <textarea data-template>
            ## FP meets Real world
	      </textarea>
      </section>

      <!-- Slide 2 -->
      <section>
        <h2>Why FP in Scala can make it hard ?</h2>
        <p>For an application code, should I be dealing with: </p>
        <ul style="font-size:35px">
          <li>Magical implicits.</li>
          <li>Free structures with boiler-plates</li>
          <li>Lifting error types everywhere - yes, type inference.</li>
          <li>Typeclass specialisations.</li>
          <li>Relatively complex code design and larger surface area</li>
        </ul>
        <p style="font-size:35px">Result is,
          <span style='color:maroon'> slower </span> development of
          <span style='color:maroon'> incomplete/FP-in-small </span> solutions
        </p>
      </section>


      <!-- Slide 3 -->

      <section>
        <h2>Sticking to fundamentals is the key</h2>
        <ul>
          <li>Total functions</li>
          <li>Programs as descriptions.</li>
          <li>Referential transparency.</li>
          <li>Type driven development.</li>
          <li>Testability / Lawful / Less bugs</li>
        </ul>
        <p> Result is,
          <strike style='color:maroon'> slower </strike> <span style='color:green'> faster </span> development of
          <strike style='color:maroon'> FP-in-small </strike> <span style='color:green'> pure FP </span> solutions.
        </p>
      </section>

      <!--Slide -->

      <section>
        <h3>Possible, if we have a proper encoding of our application domain.</h3>
      </section>
      <!-- Slide -->

      <section>
        <h3 class="fragment grow">Let us write FP for a Bigdata problem </h3>
        <h6 class="fragment">Handling REAL WORLD requirements. </h6>
        <h6 class="fragment">And finish off development fairly quickly - we have say 3 months</h6>
        <br>
      </section>

      <!-- Slide -->

      <section>
        <section id="fragments">
          <h2>The problem statement</h2>
          <h6>We have billions of events of customers clicking your netbank app.</h6>
          <h6>We have millions of customer account data.</h6>
          <h6>and so on an so forth..</h6>
        </section>
        <section>
          <p class="fragment" align="left" style="font-size:30px"> Kepp finding attributes of customers from
            Ex:
            total transactions in last 3 weeks </p>
          <p class="fragment" align="left" style="font-size:30px"> Join 1000s of them to form a wide table </p>
          <p class="fragment" align="left" style="font-size:30px"> Feed them to ML training models
          </p>
          <p class="fragment" align="left" style="font-size:30px"> We 10s of 100s of such wide tables, and each.
          </p>
          <p class="fragment" align="left" style="font-size:30px"> Quickly add/update/delete into the list of business
          </p>
          <p class="fragment" align="left" style="font-size:30px;color: coral;"> That is a thin layer of interface to
            <span style="font-weight:800;color:black;">declaratively</span>
            define <span style="font-weight:900;color:black;">clear and concise</span> business logic - <span
              style="font-weight:900;color:black;">uncluttered</span> with
            <span style="font-weight: 900;color:black;">performance related details</span> </p>
          <p class="fragment" align="left" style="font-size:30px"> We may group them (compose) the list of logic in
            anyway - may be feed them to different ML algorithms </p>
          <p class="fragment" align="left" style="font-size:30px"> It's a batch job - we don't need realtime ML
            training. </p>
        </section>
        <section>
          <h2>They are not after-thoughts</h2>
          <ul>
            <li class="fragment" style="font-size:30px">Dev should be relatively quick, we don't have much time.</li>
            <li class="fragment" style="font-size:30px">Fix performance hiccups.</li>
            <li class="fragment" style="font-size:30px">Error channels - bring them straight away into the code</li>
            <li class="fragment" style="font-size:30px">Business level DSL</li>
            <li class="fragment" style="font-size:30px">Quick fixes of imperative systems</li>
            <li class="fragment" style="font-size:30px">Backend agnostic - atleast to some extent</li>
            <li class="fragment" style="font-size:30px">Testability</li>
            <li class="fragment" style="font-size:30px">Quick addition of new capabilities</li>
            <li class="fragment" style="font-size:30px">Resource safety</li>
            <li class="fragment" style="font-size:30px">Optimisations</li>
            <li class="fragment" style="font-size:30px">Performance</li>
            <li class="fragment" style="font-size:30px">Testability / Separation of concerns</li>
            <li class="fragment" style="font-size:30px">Intuitive error handling, and AOP style logging</li>
            <li class="fragment" style="font-size:30px">All of them should compose ...</li>
          </ul>
        </section>
      </section>


      <!--Slide -->
      <section>
        <h2>A simple feature definition</h2>
        <h6> Find out sum of account balance of all customers in last 14 days.</h6>

      </section>


      <!-- Slide 18 -->

      <section data-transition="fade-out">
        <h2>A single feature definition is equivalent to</h2>
        <pre><code class="hljs sql" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          select
            customer_id,
            sum(coalesce(account_balance, 0)) 
            as "account_balance_0_14d"
          from 
          input_table
          group by customer_id
          where
            time < time_stamp() &&
            time >= minusDays(time_stamp(), 14)
        </code></pre>
        <p>Field <span style="color: cadetblue;"> "time" </span> represents data-partitioning</p>
      </section>

      <!-- Slide-->
      <section data-transition="fade-in">
        <h2>We could reduce it down to</h2>
        <pre><code class="hljs sql" style="font-size:22px;" data-trim data-line-numbers="3,4,6,10">
          select
            customer_id,
            sum(coalesce(account_balance, 0)) 
            as "account_balance_0_14d"
          from 
          input_table
          group by customer_id
          where
            time < time_stamp() &&
            time >= minusDays(time_stamp(), 14)
           </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>In short</h2>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-10">
          ...

          sum(coalesce(account_balance, 0)) 
          as "account_balance_0_14d"
          from input_table of 0-14 days

          ...
       </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>Silly thing, Fix feature name</h2>
        <pre><code class="hljs scala"  style="font-size:22px;" data-trim data-line-numbers="4">
                  ...
        
                  sum(coalesce(account_balance, 0)) 
                  as "account_balance_0_14d"
                  from input_table of 0-14 days
        
                  ...
               </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>Silly thing, Fix feature name</h2>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="4">
                        ...
              
                        sum(coalesce(account_balance, 0)) 
                        as "account_balance"
                        from input_table of 0-14 days
              
                        ...
                     </code></pre>

      </section>

      <!-- Slide -->
      <section data-transition="fade-out">
        <h2>Let's make it compile.</h2>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-6">
          FeatureDef(
            dir("input_table"),
            sum(coalesce(account_balance, 0)) 
            "account_balance"
            0 ~ 14 days
          )
         </code></pre>

        <pre><code class="hljs scala" style="font-size:19px;width: 1200px;" data-trim data-line-numbers="1-6">
            final case class FeatureDef[D, Expr](inp: Input[D], op: Expr, name: String, partition: TimeWindow)
           </code></pre>

      </section>

      <section>
        <h3>And we can have complex input.</h3>
      </section>

      <!--Slide-->
      <section data-transition="fade-out">
        <pre><code class="hljs scala"  style="font-size:22px;" data-trim data-line-numbers="2">
            FeatureDef(
              dir("input_table").join(dir("another_table")).orElse(const("myTestData")),
              sum(when("browser" == "safari") 1 else 0),
              browser_safari_count
              0 ~ 14 days
            )
           </code></pre>
      </section>

      <!-- Slide 7 -->

      <section>
        <h6>And we can have a list of them</h6>
        <pre><code style="font-size:22px;" data-trim data-line-numbers="1-10" data-noescape>
          List(
            FeatureDef(dir("account"), sum(acc_bal)......),
            FeatureDef(dir("payments"), sum(debit).when(country == 'aus')......),
            FeatureDef(dir("account").join(dir("payments")), max(acc_bal)......),
            FeatureDef(const(data), min(acc_bal)......),
          )

         </code></pre>
      </section>

      <!-- Slide 5 -->

      <section>
        <h2>What next?</h2>
        <h4> We need to compose them.</h4>
        We need more combinators. But to begin with,
        <pre><code class=" hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-100">
            def start(featureDef: FeatureDef[D]): FeatureGen[FeatureRes[D]] = ???
  
            final case class FeatureRes[D](result: D, metadata: Metadata)
            final case class Metadata(name: FeatureName, source: Vector[String])
            </code></pre>
      </section>

      <!-- Slide 8 -->

      <section>
        <section>
          <h3>The structure.</h3>
          <pre><code class="hljs scala" style="font-size:22px;width: 1200px;" data-line-numbers="1-10"  data-trim>
                  sealed trait FeatureGen[D, E, A] { self =>   
                    def <*>[B](feature2: FeatureGen[D, E, B]): FeatureGen[D, E, (A, B)] =
                      FeatureGen.Zip(self, feature2)
    
                    def map2[B, C](that: FeatureGen[D, E, B])(f: (A, B) => C): FeatureGen[D, E, C] =
                      (self zip that).map({ case (a, b) => f(a, b) })
                  
                    def map[B](f: A => B): FeatureGen[D, E, B] =
                      FeatureGen.Map(self, f)
                  }
                  </code></pre>
          </code></pre>
        </section>
        <section>
          <pre><code class="hljs scala" style="font-size:19px;" data-noescape>
                <p style="font-size:21px;text-align:center;"><span style="color: cadetblue;">D</span> is data</p>
            <p style="font-size:21px;text-align:center;"><span style="color: cadetblue;">E</span> is Expression that can operate on data</p>
            <p style="font-size:21px;text-align:center;"><span style="color: cadetblue;">A</span> is the result A</p>
          </code></pre>
        </section>
        <section>
          <pre><code class="hljs scala" style="font-size:19px;">
  final case class Pure[A](value: A) extends FeatureGen[Nothing, Nothing, A]
  final case class Zip[D, E, A, B](f: FeatureGen[D, E, A], g: FeatureGen[D, E, B]) extends FeatureGen[D, Expr, (A, B)]
  final case class Map[D, E, A, B](feature1: FeatureGen[D, E, A], f: A => B) extends FeatureGen[D, E, B]
  final case class CreateFeatures[D, E](input: FeatureDef[D, E]) extends FeatureGen[D, E, FeatureRes[D]]
  final case class JoinFeatures[D, E](
    f1: FeatureGen[D, E, FeatureRes[D]], 
    f2: FeatureGen[D, E, FeatureRes[D]]
  ) extends FeatureGen[D, E, FeatureRes[D]]
            </code></pre>
        </section>
        <section>
          <h4>Our helper functions</h4>
          <pre><code class="hljs scala" style="font-size:19px;" data-trim>

          def start[D, Expr, A](featureDef: FeatureDef[D, Expr]): FeatureGen[D, Expr, FeatureRes[D]] =
            CreateFeatures(featureDef)

          def pure[D, Expr, A](value: => A): FeatureGen[D, Expr, A] =
            FeatureGen.Pure(value)

          def fail[A](message: String): FeatureGen[Nothing, Nothing, A] =
            FeatureGen.Fail(message)

          def join[D, Expr,](f1: FeatureGen[D, Expr, FeatureRes[D]], f2: FeatureGen[D, Expr, FeatureRes[D]]): FeatureGen[D, Expr, A] =
            FeatureGen.Join(f1, f2)

          def combineAll[D, Expr. A](list: ::[FeatureGen[D, Expr, FeatureRes[D]]]): FeatureGen[D, Expr, FeatureRes[D]] = 
            list.reduce(a, b => join(a, b))          
        </code></pre>
        </section>

        <section data-transition="fade-out">
          <h5>Sequence ??? </h5>
          <pre><code class="hljs scala" style="font-size:19px;" data-trim>
              def sequence[D, E, A](list: List[FeatureGen[D, E, A]]): FeatureGen[D, E, List[A]] = 
                list.foldLeft(pure[List[A]](Nil))((aa, bb) => bb.map2(aa)(_ :: _))

              def collectAll(list: List[FeatureGen[D, E, A]]): FeatureGen[D, E, List[A]] = 
                sequence(list)  
            </code></pre>
        </section>

        <!--Sections grouped together; Start-->
        <section data-transition="fade-out">
          <h5>Once the features are defined we get to compose them in many ways.</h5>
          <pre><code class=" hljs scala" style="font-size:24px; align-items: center;" data-line-numbers="1000" data-trim data-noescape>  
              val aJob: FeatureGen[FeatureResult[D]] = 
                start(defn)

              val result = FeatureGen.collectAll(job1.join(job2).join(job3), job4, job5)    
              
              val anotherResult = FeatureGen.combineAll(List(job6, job7, job8, jb9))

              anotherResult.map(_.metadata.size)

              // and so forth

              </code></pre>
        </section>

        <section data-transition="fade-out">
          <h5>Once the features are defined we get to compose them in many ways.</h5>
          <pre><code class=" hljs scala" style="font-size:24px; align-items: center;" data-line-numbers="1,2" data-trim data-noescape>  
                val aJob: FeatureGen[FeatureResult[D]] = 
                  start(aJob)
  
                val result = FeatureGen.collectAll(job1.join(job2).join(job3), job4, job5)    
                
                val anotherResult = FeatureGen.combineAll(List(job6, job7, job8, jb9))
  
                anotherResult.map(_.metadata.size)
  
                // and so forth
  
                </code></pre>
        </section>

        <section data-transition="fade-out">
          <h5>Once the features are defined we get to compose them in many ways.</h5>
          <pre><code class=" hljs scala" style="font-size:24px; align-items: center;" data-line-numbers="4" data-trim data-noescape>  
                  val aJob: FeatureGen[FeatureResult[D]] = 
                    start(aJob)
    
                  val result = FeatureGen.collectAll(job1.join(job2).join(job3), job4, job5)    
                  
                  val anotherResult = FeatureGen.combineAll(List(job6, job7, job8, jb9))
    
                  anotherResult.map(_.metadata.size)
    
                  // and so forth
    
                  </code></pre>
        </section>

        <section data-transition="fade-out">
          <h5>Once the features are defined we get to compose them in many ways.</h5>
          <pre><code class=" hljs scala" style="font-size:24px; align-items: center;" data-line-numbers="6" data-trim data-noescape>  
                    val aJob: FeatureGen[FeatureResult[D]] = 
                      start(aJob)
      
                    val result = FeatureGen.collectAll(job1.join(job2).join(job3), job4, job5)    
                    
                    val anotherResult = FeatureGen.combineAll(List(job6, job7, job8, jb9))
      
                    anotherResult.map(_.metadata.size)
      
                    // and so forth
      
                    </code></pre>
        </section>

        <section data-transition="fade-out">
          <h5>Once the features are defined we get to compose them in many ways.</h5>
          <pre><code class=" hljs scala" style="font-size:24px; align-items: center;" data-line-numbers="8,9,10" data-trim data-noescape>  
                      val aJob: FeatureGen[FeatureResult[D]] = 
                        start(aJob)
        
                      val result = FeatureGen.collectAll(job1.join(job2).join(job3), job4, job5)    
                      
                      val anotherResult = FeatureGen.combineAll(List(job6, job7, job8, jb9))
        
                      anotherResult.map(_.metadata.size)
        
                      // and so forth
        
                      </code></pre>
        </section>

        <!--Sections grouped together; Start-->

        <!-- Slide 5 -->

        <section>
          <h2>Run <span style="color: red;">FeatureGen</span></h2>
          <ul>
            <li>We can have a single implementation to target effect that can deal with side effects</li>
            <li>For that we need an effect that's richer with types!</li>
            <li>In other words, we can't keep traversing through FeatureGen to plug new backends/test-services</li>
          </ul>
        </section>

        <section data-background="images/ZIO.png" data-state="dimbg">
          <h2>Going forward, We are using ZIO</h2>
          <ul>
            <li>Relatively easy to pick up</li>
            <li>No implicit schedule/timer</li>
            <li>Easy concurrrency</li>
            <li>Awesome type inference</li>
          </ul>
        </section>

        <!-- Slide 6 -->
        <section data-background="images/ZIO.png" data-state="dimbg">
          <h2> The mental model of ZIO </h2>
          <div>
            <pre><code class="hljs scala" data-trim>
                  ...
  
                    ZIO[R, E, A]
                    // ZIO[Environment, Error, Result]
                  ...
             </code></pre>

          </div>
          <div>
            <pre><code class="hljs scala" data-trim>
                  ...
  
                    R => Either[E, A]
  
                    // Given an input R,
                    // the computation either returns an Error or a result A.
                  ...
              </code></pre>
          </div>
        </section>

        <section>
          <h2>Run implementation of ZIO</h2>
          <p style="font-size: 20px;">We need a richer target to not deal with recursion more than once! </p>
          <pre><code class=" hljs scala" style="font-size:30px; align-items: center;" data-trim data-noescape>
            <span style="text-align: center;"> 
              type AnalyticsTask[D, Expr, A] = ZIO[DataService[D, Expr], AppError, A] 
            </span>
            </code></pre>
          <p style="font-size: 20px;">Were, DataService knows about how to do basic ops on data.</p>
        </section>
        <section>
          <h6> Interpreting any FeatureGen[D, Expr, A] to AnalyticsTask</h6>
          <pre><code class="hljs scala" style="font-size:19px;">
              def run[D, Expr, A] = FeatureGen[D, Expr, A]) => AnalyticsTask[A]
             </code></pre>
        </section>
        <section>
          <h3>Let's look at what's in DataService</h3>
          <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
            trait DataService[D, Expr] {
              def get(input: Input[D], partition: Option[Window]): Task[D]
              def generateFeature(d: D, featureRequest: FeatureDef[D, Expr]): Task[D]
              def join(left: D, right: D): Task[D]
              def projectFeatures(d: D, value: List[Logic[Expr]]): Task[D]
            }
              </code></pre>
        </section>
        <section>
          <h2>Let's write this one out!</h2>
          <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
        def run[D, Expr, A]: FeatureGen[D, Expr, A] => AnalyticsTask[A] = 
          fa =>
            def apply[A](fa: FeatureGen[D, Expr, A]): AnalyticsTask[A] = {
              fa match {
                case Pure(value)      => ZIO.succeed(value)
                case Zip(pgm1, pgm2)  => apply(pgm1).zip(apply(pgm2))
                case Map(pgm, f)      => apply(pgm).map(f)
                case Fail(message)    => ZIO.fail(new AppError(message))
                ... // In next slides
              }

          apply(fa)
        }
       }
                </code></pre>
        </section>
        <section>
          <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
          ...
            case JoinFeatures(feature1, feature2) =>
            apply(feature1)
              .zip(apply(feature2))
              .flatMap({
                case (f1, f2) =>
                  ZIO.accessM[DataOp.Service[D, Expr]](
                    r => r.join(f1.value, f2.value).map(r => FeatureRes(r, f1.metadata ++ f2.metadata))
                  )
              })
            ...  
            </code></pre>

        </section>
        <section>
          <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
            case CreateFeatures(input) =>
              ZIO.accessM(service =>
                env.generateFeature(input.data, input.logic, input.partition)
                  .map(r =>
                    FeatureRes(result, input.logic.map(t => Metadata(FeatureName(t.name, input.forPartition), input.input.toString)))
                  )
              })
            )
          </code></pre>
        </section>
        <section>
          <h6>Let's run, for that we need an implementation. Let' go with Flink</h6>
          For that, we need to implement a Flink DataService, which is in real a 15 line code.
          <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
              val flinkSerive = new DataService[flink.Table, flink.Expression] {
                def get(input: Input[D], partition: Option[TimeWindow]): Task[Table] = ???
                def generateFeature(d: Table, featureRequest: FeatureDef[Table, Expression]): Task[Table] = ???
                def join(left: Table, right: Table): Task[Table] = ???
                def projectFeatures(d: D, value: List[Logic[Expression]]): Task[Table] = ????
              }
            </code></pre>
        </section>
        <section>
          <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
            val job: FeatureGen[Table, Expression] = ???
            run(job).provide(flinkService)
              </code></pre>
        </section>
        <section>
          <h2>Let's define the set of features !</h2>
          <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-100" data-noescape>
                List(
                  FeatureDef(
                    const(table),
                    'accountBalance.sum,
                    "sum_account_balance",
                    0 ~ 2 weeks
                  ),
                  FeatureDef(
                    const(table),
                    'accountBalance.max,
                    "max_account_balance",
                    0 ~ 2 weeks
                  ),
                  FeatureDef(
                    const(table),
                    'accountBalance.sum,
                    "sum_account_balance",
                    2 ~ 4 weeks
                  ),
                  FeatureDef(
                    const(table),
                    'accountBalance.max,
                    "max_account_balance",
                    2 ~ 4 weeks
                  ),
                  FeatureDef(
                    const(table),
                    'accountBalance.sum,
                    "sum_account_balance",
                    0 ~ 4 weeks,
                    Some((a: Expression, b: Expression) => a + b)
                  ),
                  FeatureDef(
                    const(table),
                    'accountBalance.max,
                    "max_account_balance",
                    0 ~ 4 weeks,
                    Some((a: Expression, b: Expression) => (a > b) ? (a, b))
                  )
                              </code></pre>

        </section>
        <section>
          <h4>Without Any Optimiser</h4>
          <video width="1000" height="680" controls>
            <source src="images/fully_unoptimised.mov" type="video/mp4">
          </video>
        </section>


        <section>
          <h4>We hit the first real world.</h4>
          That is worst in all sense, but the most important one is, the joins are sequential.
        </section>

        <!-- Slide -->
        <section>
          <h4> A Simplified version. </h4>
          <img src="images/worst.png" width=1000 style="border: none;">
        </section>

        <!--Slide-->
        <section>
          <h4> Can our abstraction solve this ?</h4>
        </section>


      </section>

      <!-- Slide 9 -->

      <section>
        <pre><code class="hljs scala">
def findRequests(
  x: FeatureGen[D, Expr, B]
 ): List[SMap[Source[D], List[Logic[Expr]]]] = ???
            </code></pre>
      </section>

      <!-- Slide 10 -->

      <section>
        <pre><code class="hljs scala" style="font-size:22px;">
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
    fa match {
      case CreateFeatures(featureDef) => ???
      case JoinFeatures(f1, f2) => ???
      case Pure(_)              => ???
      case Map(f1, _)           => ???
      case Zip(f1, f2)          => ???
      case Fail(_)              => ???
    }
}
            </code></pre>
      </section>


      <!-- Slide 11 - code0 -->

      <section data-transition="fade-out">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="7,8,9" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}

            </code></pre>
      </section>

      <!-- Slide 12 - code0 -->


      <section data-transition="fade-in">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="9,10" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
      </code></pre>
      </section>


      <!-- Slide 13 - code0 -->


      <section data-transition="fade-out">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="11" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}

            </code></pre>
      </section>

      <!-- Slide 14 - code0 -->


      <section data-transition="fade-in">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="12" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
      </section>


      <!-- Slide 15 - code0 -->

      <section data-transition="fade-out">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="13" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
      </section>

      <!-- Slide 16 - code0 -->

      <section data-transition="fade-in">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="14" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
      </section>

      <!-- Slide -->

      <section>
        <h2> Results - Let's Flink </h2>
      </section>

      <!-- Slide -->
      <section>
        <h2>Let's define the set of features !</h2>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-100" data-noescape>
            List(
              FeatureDef(
                const(table),
                'accountBalance.sum,
                "sum_account_balance",
                0 ~ 2 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.max,
                "max_account_balance",
                0 ~ 2 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.sum,
                "sum_account_balance",
                2 ~ 4 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.max,
                "max_account_balance",
                2 ~ 4 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.sum,
                "sum_account_balance",
                0 ~ 4 weeks,
                Some((a: Expression, b: Expression) => a + b)
              ),
              FeatureDef(
                const(table),
                'accountBalance.max,
                "max_account_balance",
                0 ~ 4 weeks,
                Some((a: Expression, b: Expression) => (a > b) ? (a, b))
              )
                          </code></pre>

      </section>

      <!-- Slide -->

      <section>
        <h4>Without Any Optimiser</h4>
        <video width="1000" height="680" controls>
          <source src="images/fully_unoptimised.mov" type="video/mp4">
        </video>
      </section>

      <!-- Slide -->
      <section>
        <h4> (Over) Simplified.. </h4>
        <img src="images/worst.png" width=1000 style="border: none;">
      </section>

      <!-- Slide -->

      <section>
        <h4>With Join Optimiser</h3>
          <video width="1000" height="680" controls>
            <source src="images/combineAllEffJoin.mov" type="video/mp4">
          </video>
      </section>

      <!-- Slide -->
      <section>
        <h4> Simplified.. </h4>
        <img src="images/divide_n_conquer.png" style="border: none;" width=800>
      </section>

      <!-- Slide -->

      <section>
        <h4>With Join and Aggregation Optimiser</h2>
          <video width="1000" height="680" controls>
            <source src="images/reduce_aggregations.mov" type="video/mp4">
          </video>
      </section>

      <!-- Slide -->
      <section>
        <h4> Simplified.. </h4>
        <img src="images/reduce_aggregation.png" style="border: none;" width=800>
      </section>

      <!-- Slide -->

      <section>
        <h4>With Join, Aggregation & Reuse Optimiser</h4>
        <video width="1000" height="600" controls>
          <source src="images/thbestplan.mov" type="video/mp4">
        </video>
      </section>

      <!-- Slide -->
      <section>
        <h4> Simplified.. </h4>
        <img src="images/thbestplan.png" style="border: none;" width=800>
      </section>

      <!-- Slide -->
      <section>
        <table>
          <tr>
            <th align="center">
              Before
            </th>
            <th align="center">
              After
            </th>
          </tr>
          <tr>
            <th>
              <img src="images/worst.png" style="border: none;" width=1000>
            </th>
            <th>
              <img src="images/thbestplan.png" style="border: none;" width=650>
            </th>
          </tr>
        </table>
      </section>

      <!-- Slide -->

      <section>
        <h4>Summary of FP principles</h4>

        The basic principle is that,
        by weakening the monadic interface to that of an
        applicative functor (or, more precisely, an alternative functor),
        it becomes possible to perform enough static
        analysis to compute first sets for productions.


      </section>

      <!-- Slide 20 -->
    </div>
  </div>

  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      // ...

      // The "normal" size of the presentation, aspect ratio will be preserved
      // when the presentation is scaled to fit different resolutions. Can be
      // specified using percentage units.
      width: 1300,
      height: 750,

      // Factor of the display size that should remain empty around the content
      margin: 0.1,

      // Bounds for smallest/largest possible scale to apply to content
      minScale: 0.2,
      maxScale: 1.5,
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true },
        { src: 'https://d3js.org/d3.v4.min.js' },
        { src: 'plugin/d3js/d3js.js' }
      ]
    });







  </script>
</body>

</html>