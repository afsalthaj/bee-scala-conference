<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/beige.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/monokai.css">


  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);

  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <!-- Heading section -->
      <section data-markdown>
        <textarea data-template>
            ## FP meets Real world
	      </textarea>
      </section>

      <!-- Slide 2 -->
      <section>
        <h2>Why FP in Scala can make it hard ?</h2>
        <p>For an application code, should I be dealing with: </p>
        <ul style="font-size:35px">
          <li>Magical implicits.</li>
          <li>Free structures with boiler-plates</li>
          <li>Lifting error types everywhere - yes, type inference.</li>
          <li>Typeclass specialisations.</li>
          <li>Relatively complex code design and larger surface area</li>
        </ul>
        <p style="font-size:35px">Result is,
          <span style='color:maroon'> slower </span> development of
          <span style='color:maroon'> incomplete/FP-in-small </span> solutions
        </p>
      </section>


      <!-- Slide 3 -->

      <section>
        <h2>Sticking on to fundamentals is the key</h2>
        <ul>
          <li>Total functions</li>
          <li>Programs as descriptions.</li>
          <li>Referential transparency.</li>
          <li>Type driven development.</li>
          <li>Testability / Lawful / Less bugs</li>
        </ul>
        <p> Result is,
          <strike style='color:maroon'> slower </strike> <span style='color:green'> faster </span> development of
          <strike style='color:maroon'> FP-in-small </strike> <span style='color:green'> pure FP </span> solutions.
        </p>
      </section>

      <!-- Slide 4 -->

      <section>
        <h2> Hence we have, and we need</h2>
        <ul>
          <li>Quick addition of new capabilities</li>
          <li>Resource safety</li>
          <li>Optimisations</li>
          <li>Performance</li>
          <li>Testability / Separation of concerns</li>
          <li>Intuitive error handling, and AOP style logging</li>
          <li>All of them should compose ...</li>
        </ul>
      </section>

      <!-- Slide -->

      <section>
        <h3 class="fragment grow">Let us write FP for a Bigdata problem </h3>
        <h6 class="fragment">Handling REAL WORLD requirements. </h6>
        <h6 class="fragment">And finish off development fairly quickly - we have say 3 months</h6>
        <br>
      </section>

      <!-- Slide -->

      <section>
        <section id="fragments">
          <h2>The problem statement</h2>
          <h6>We have billions of events of customers clicking your netbank app.</h6>
          <h6>We have millions of customer account data.</h6>
          <h6>and so on an so forth..</h6>
        </section>
        <section>
          <p class="fragment" align="left" style="font-size:30px"> We keep finding various attributes of customers -
            Ex:
            total transactions in last 3 weeks </p>
          <p class="fragment" align="left" style="font-size:30px"> We join those features to form a wide table </p>
          <p class="fragment" align="left" style="font-size:30px"> We should feed them to different ML training models
          </p>
          <p class="fragment" align="left" style="font-size:30px"> And we can have 100s of such wide tables, and each
            one can
            have 1000s of attributes/features
          </p>
          <p class="fragment" align="left" style="font-size:30px"> We need to quickly add new business logic - new
            attributes/features </p>
          <p class="fragment" align="left" style="font-size:30px"> That is a thin layer of interface to declaratively
            define clear and concise business logic - uncluttered with performance related details </p>
          <p class="fragment" align="left" style="font-size:30px"> We may group them (compose) the list of logic in
            anyway - may be feed them to different ML algorithms </p>
          <p class="fragment" align="left" style="font-size:30px"> It's a batch job - we don't need realtime ML
            training. </p>
        </section>
        <section>
          <h2>They are not after-thoughts</h2>
          <ul>
            <li class="fragment" style="font-size:30px">We should be able to introspect for quick performance hiccups
              due to declarative interface.</li>
            <li class="fragment" style="font-size:30px">Error channels - bring them straight away into the code</li>
            <li class="fragment" style="font-size:30px">Business level DSL</li>
            <li class="fragment" style="font-size:30px">Quick fixes of imperative systems</li>
            <li class="fragment" style="font-size:30px">Backend agnostic - atleast to some extent</li>
            <li class="fragment" style="font-size:30px">Testability</li>
            <li class="fragment" style="font-size:30px">Should be relatively quick, we don't have much time.</li>
          </ul>
        </section>
      </section>


      <!--Slide -->
      <section>
        <h2>A simple feature definition</h2>
        <h6> Find out sum of account balance of all customers in last 14 days.</h6>

      </section>


      <!-- Slide 18 -->

      <section data-transition="fade-out">
        <h2>A single feature definition is equivalent to</h2>
        <pre><code class="hljs sql" data-trim data-trim data-line-numbers="1-10">
          select
            customer_id,
            sum(coalesce(account_balance, 0)) 
            as "account_balance_0_14d"
          from 
          input_table
          group by customer_id
          where
            time < time_stamp() &&
            time >= minusDays(time_stamp(), 14)
        </code></pre>

      </section>

      <!-- Slide-->
      <section data-transition="fade-in">
        <h2>We could reduce it down to</h2>
        <pre><code class="hljs sql" data-trim data-line-numbers="3,4,6,10">
          select
            customer_id,
            sum(coalesce(account_balance, 0)) 
            as "account_balance_0_14d"
          from 
          input_table
          group by customer_id
          where
            time < time_stamp() &&
            time >= minusDays(time_stamp(), 14)
           </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>In short</h2>
        <pre><code class="hljs scala" data-trim data-line-numbers="1-10">
          ...

          sum(coalesce(account_balance, 0)) 
          as "account_balance_0_14d"
          from input_table of 0-14 days

          ...
       </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>Silly thing, Fix feature name</h2>
        <pre><code class="hljs scala" data-trim data-line-numbers="4">
                  ...
        
                  sum(coalesce(account_balance, 0)) 
                  as "account_balance_0_14d"
                  from input_table of 0-14 days
        
                  ...
               </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>Silly thing, Fix feature name</h2>
        <pre><code class="hljs scala" data-trim data-line-numbers="4">
                        ...
              
                        sum(coalesce(account_balance, 0)) 
                        as "account_balance"
                        from input_table of 0-14 days
              
                        ...
                     </code></pre>

      </section>

      <!-- Slide -->
      <section data-transition="fade-out">
        <h2>Let's make it compile.</h2>
        <pre><code class="hljs scala" data-trim data-line-numbers="1-6">
          FeatureDef(
            dir("input_table"),
            sum(coalesce(account_balance, 0)) 
            "account_balance"
            0 ~ 14 days
          )
         </code></pre>

      </section>

      <section>
        <h3>And we can have complex input.</h3>
      </section>

      <!--Slide-->
      <section data-transition="fade-out">
        <pre><code class="hljs scala" data-trim data-line-numbers="2">
            FeatureDef(
              dir("input_table").join(dir("another_table")).orElse(const("myTestData")),
              sum(when("browser" == "safari") 1 else 0),
              browser_safari_count
              0 ~ 14 days
            )
           </code></pre>
      </section>

      <!-- Slide 7 -->

      <section>
        <h6>And we can have a list of them</h6>
        <pre><code class="hljs" data-trim data-line-numbers="1-10">
          List(
            FeatureDef(dir("account"), sum(acc_bal)......),
            FeatureDef(dir("payments"), sum(debit).when(country == 'aus')......),
            FeatureDef(dir("account").join(dir("payments")), max(acc_bal)......),
            FeatureDef(const(data), min(acc_bal)......),
          )

         </code></pre>
      </section>

      <!-- Slide 5 -->

      <section>
        <h6>What next?</h6>
        We should be able to compose programs.
        <p class="frament">An interface to use the list the way user needs.</p>
      </section>

      <section>
        <h6> Something along ther lines of</h6>
        <pre><code class="hljs scala" data-trim data-line-numbers="1-100">
            val list: List[FeatureDef[D]] = ???
            
            def start(featureDef: FeatureDef[D]): FeatureGen[FeatureResult[D]] = ???

            // for instance, let's sequence it.
            val listOfWideTables: FeatureGen[List[FeatureRes[D]]] = 
              list.map(start).sequence

            // and probably feed the list of wide tables to different ML
            val job: FeatureGen[List[D] = 
              listOfWideTables.flatMap(regressionModel.train)
          
           </code></pre>

      </section>

      <!-- Slide 5 -->


      <!-- Slide 5 -->

      <section>
        <h2>Eyes on:</h2>
        <ul>
          <li>Effects: ZIO</li>
          <li>Semigroup</li>
          <li>Natural Transformation: The impl of abstraction into ZIO</li>
        </ul>
        <p>We use ZIO for a variety of reasons.</p>
      </section>

      <!-- Slide 6 -->

      <section>
        <h2> The mental model of ZIO </h2>
        <div>
          <pre><code class="hljs scala" data-trim>
                  ...
  
                    ZIO[R, E, A]
                    // ZIO[Environment, Error, Result]
                  ...
             </code></pre>

        </div>
        <div>
          <pre><code class="hljs scala" data-trim>
                  ...
  
                    R => Either[E, A]
  
                    // Given an input R,
                    // the computation either returns an Error or a result A.
                  ...
              </code></pre>
        </div>
      </section>

      <!--Slide-->

      <section>
        <pre><code class="hljs scala">
                ...

                  sealed trait FeatureGen[D, Expr, A]

                ...
            </code></pre>
      </section>

      <!-- Slide 8 -->


      <section>
        <pre><code class="hljs scala" style="font-size:19px">
                ...

final case class CreateFeatures[D, Expr](input: FeatureDef[D, Expr]) extends FeatureGen[D, Expr, FeatureRes[D]]
              ...

            </code></pre>
      </section>


      <!-- Slide 9 -->

      <section>
        <pre><code class="hljs scala">
def findRequests(
  x: FeatureGen[D, Expr, B]
 ): List[SMap[Source[D], List[Logic[Expr]]]] = ???
            </code></pre>
      </section>

      <!-- Slide 10 -->

      <section>
        <pre><code class="hljs scala" style="font-size:19px">
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
    fa match {
      case CreateFeatures(featureDef) => ???
      case JoinFeatures(f1, f2) => ???
      case Pure(_)              => ???
      case Map(f1, _)           => ???
      case Zip(f1, f2)          => ???
      case Fail(_)              => ???
    }
}
            </code></pre>
      </section>


      <!-- Slide 11 - code0 -->

      <section data-transition="fade-out">
        <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="7,8,9" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}

            </code></pre>
      </section>

      <!-- Slide 12 - code0 -->


      <section data-transition="fade-in">
        <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="9,10" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
      </code></pre>
      </section>


      <!-- Slide 13 - code0 -->


      <section data-transition="fade-out">
        <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="11" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}

            </code></pre>
      </section>

      <!-- Slide 14 - code0 -->


      <section data-transition="fade-in">
        <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="12" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
      </section>


      <!-- Slide 15 - code0 -->

      <section data-transition="fade-out">
        <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="13" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
      </section>

      <!-- Slide 16 - code0 -->

      <section data-transition="fade-in">
        <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="14" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
      </section>

      <!-- Slide -->

      <section>
        <h2> Results - Let's Flink </h2>
      </section>

      <!-- Slide -->
      <section>
        <h2>Let's define the set of features !</h2>
        <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="1-100" data-noescape>
            List(
              FeatureDef(
                const(table),
                'accountBalance.sum,
                "sum_account_balance",
                0 ~ 2 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.max,
                "max_account_balance",
                0 ~ 2 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.sum,
                "sum_account_balance",
                2 ~ 4 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.max,
                "max_account_balance",
                2 ~ 4 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.sum,
                "sum_account_balance",
                0 ~ 4 weeks,
                Some((a: Expression, b: Expression) => a + b)
              ),
              FeatureDef(
                const(table),
                'accountBalance.max,
                "max_account_balance",
                0 ~ 4 weeks,
                Some((a: Expression, b: Expression) => (a > b) ? (a, b))
              )
                          </code></pre>

      </section>

      <!-- Slide -->

      <section>
        <h4>Without Any Optimiser</h4>
        <video width="500" height="500" controls>
          <source src="/images/fully_unoptimised.mov" type="video/mp4">
        </video>
      </section>

      <!-- Slide -->

      <section>
        <h4>With Join Optimiser</h3>
          <video width="500" height="500" controls>
            <source src="/images/combineAllEffJoin.mov" type="video/mp4">
          </video>
      </section>

      <!-- Slide -->

      <section>
        <h4>With Join and Aggregation Optimiser</h2>
          <video width="500" height="500" controls>
            <source src="/images/reduce_aggregations.mov" type="video/mp4">
          </video>
      </section>

      <!-- Slide -->

      <section>
        <h4>With Join, Aggregation & Reuse Optimiser</h4>
        <video width="500" height="500" controls>
          <source src="/images/thbestplan.mov" type="video/mp4">
        </video>
      </section>

      <!-- Slide 20 -->
    </div>
  </div>

  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      // ...

      // The "normal" size of the presentation, aspect ratio will be preserved
      // when the presentation is scaled to fit different resolutions. Can be
      // specified using percentage units.
      width: 1300,
      height: 750,

      // Factor of the display size that should remain empty around the content
      margin: 0.1,

      // Bounds for smallest/largest possible scale to apply to content
      minScale: 0.2,
      maxScale: 1.5,
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true },
        { src: 'https://d3js.org/d3.v4.min.js' },
        { src: 'plugin/d3js/d3js.js' }
      ]
    });







  </script>
</body>

</html>