<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/beige.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/magula.css">


  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);

  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <!-- Heading section -->
      <section data-markdown>
        <textarea data-template>
            ## FP meets Real world
	      </textarea>
      </section>

      <!-- Slide 2 -->
      <section>
        <h2>Why FP in Scala can make it hard ?</h2>
        <p>For an application code, should I be dealing with: </p>
        <ul style="font-size:35px">
          <li>Magical implicits.</li>
          <li>Free structures with boiler-plates</li>
          <li>Lifting error types everywhere - yes, type inference.</li>
          <li>Typeclass specialisations.</li>
          <li>Relatively complex code design and larger surface area</li>
        </ul>
        <p style="font-size:35px">Result is,
          <span style='color:maroon'> slower </span> development of
          <span style='color:maroon'> incomplete/FP-in-small </span> solutions
        </p>
      </section>


      <!-- Slide 3 -->

      <section>
        <h2>Sticking to fundamentals is the key</h2>
        <ul>
          <li>Total functions</li>
          <li>Programs as descriptions.</li>
          <li>Referential transparency.</li>
          <li>Type driven development.</li>
          <li>Testability / Lawful / Less bugs</li>
        </ul>
        <p> Result is,
          <strike style='color:maroon'> slower </strike> <span style='color:green'> faster </span> development of
          <strike style='color:maroon'> FP-in-small </strike> <span style='color:green'> pure FP </span> solutions.
        </p>
      </section>

      <!--Slide -->

      <section>
        <h3>Possible, if we have a proper encoding of our application domain.</h3>
      </section>
      <!-- Slide -->

      <section>
        <h3 class="fragment grow">Let us write FP for a Bigdata problem </h3>
        <h6 class="fragment">Handling REAL WORLD requirements. </h6>
        <h6 class="fragment">And finish off development fairly quickly - we have say 3 months</h6>
        <br>
      </section>

      <!-- Slide -->

      <section>
        <section id="fragments">
          <h2>The problem statement</h2>
          <h6>We have billions of events of customers clicking your netbank app.</h6>
          <h6>We have millions of customer account data.</h6>
          <h6>and so on an so forth..</h6>
        </section>
        <section>
          <p class="fragment" align="left" style="font-size:30px"> Kepp finding attributes of customers from
            Ex:
            total transactions in last 3 weeks </p>
          <p class="fragment" align="left" style="font-size:30px"> Join 1000s of them to form a wide table </p>
          <p class="fragment" align="left" style="font-size:30px"> Feed them to ML training models
          </p>
          <p class="fragment" align="left" style="font-size:30px"> We 10s of 100s of such wide tables, and each.
          </p>
          <p class="fragment" align="left" style="font-size:30px"> Quickly add/update/delete into the list of business
          </p>
          <p class="fragment" align="left" style="font-size:30px;color: coral;"> That is a thin layer of interface to
            <span style="font-weight:800;color:black;">declaratively</span>
            define <span style="font-weight:900;color:black;">clear and concise</span> business logic - <span
              style="font-weight:900;color:black;">uncluttered</span> with
            <span style="font-weight: 900;color:black;">performance related details</span> </p>
          <p class="fragment" align="left" style="font-size:30px"> We may group them (compose) the list of logic in
            anyway - may be feed them to different ML algorithms </p>
          <p class="fragment" align="left" style="font-size:30px"> It's a batch job - we don't need realtime ML
            training. </p>
        </section>
        <section>
          <h2>They are not after-thoughts</h2>
          <ul>
            <li class="fragment" style="font-size:30px">Dev should be relatively quick, we don't have much time.</li>
            <li class="fragment" style="font-size:30px">Fix performance hiccups.</li>
            <li class="fragment" style="font-size:30px">Error channels - bring them straight away into the code</li>
            <li class="fragment" style="font-size:30px">Business level DSL</li>
            <li class="fragment" style="font-size:30px">Quick fixes of imperative systems</li>
            <li class="fragment" style="font-size:30px">Backend agnostic - atleast to some extent</li>
            <li class="fragment" style="font-size:30px">Testability</li>
            <li class="fragment" style="font-size:30px">Quick addition of new capabilities</li>
            <li class="fragment" style="font-size:30px">Resource safety</li>
            <li class="fragment" style="font-size:30px">Optimisations</li>
            <li class="fragment" style="font-size:30px">Performance</li>
            <li class="fragment" style="font-size:30px">Testability / Separation of concerns</li>
            <li class="fragment" style="font-size:30px">Intuitive error handling, and AOP style logging</li>
            <li class="fragment" style="font-size:30px">All of them should compose ...</li>
          </ul>
        </section>
      </section>


      <!--Slide -->
      <section>
        <h2>A simple feature definition</h2>
        <h6> Find out sum of account balance of all customers in last 14 days.</h6>

      </section>


      <!-- Slide 18 -->

      <section data-transition="fade-out">
        <h2>A single feature definition is equivalent to</h2>
        <pre><code class="hljs sql" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          select
            customer_id,
            sum(coalesce(account_balance, 0)) 
            as "account_balance_0_14d"
          from 
          input_table
          group by customer_id
          where
            time < time_stamp() &&
            time >= minusDays(time_stamp(), 14)
        </code></pre>
        <p>Field <span style="color: cadetblue;"> "time" </span> represents data-partitioning</p>
      </section>

      <!-- Slide-->
      <section data-transition="fade-in">
        <h2>We could reduce it down to</h2>
        <pre><code class="hljs sql" style="font-size:22px;" data-trim data-line-numbers="3,4,6,10">
          select
            customer_id,
            sum(coalesce(account_balance, 0)) 
            as "account_balance_0_14d"
          from 
          input_table
          group by customer_id
          where
            time < time_stamp() &&
            time >= minusDays(time_stamp(), 14)
           </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>In short</h2>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-10">
          ...

          sum(coalesce(account_balance, 0)) 
          as "account_balance_0_14d"
          from input_table of 0-14 days

          ...
       </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>Silly thing, Fix feature name</h2>
        <pre><code class="hljs scala"  style="font-size:22px;" data-trim data-line-numbers="4">
                  ...
        
                  sum(coalesce(account_balance, 0)) 
                  as "account_balance_0_14d"
                  from input_table of 0-14 days
        
                  ...
               </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>Silly thing, Fix feature name</h2>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="4">
                        ...
              
                        sum(coalesce(account_balance, 0)) 
                        as "account_balance"
                        from input_table of 0-14 days
              
                        ...
                     </code></pre>

      </section>

      <!-- Slide -->
      <section data-transition="fade-out">
        <h2>Let's make it compile.</h2>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-6">
          FeatureDef(
            dir("input_table"),
            sum(coalesce(account_balance, 0)) 
            "account_balance"
            0 ~ 14 days
          )
         </code></pre>

        <pre><code class="hljs scala" style="font-size:19px;width: 1200px;" data-trim data-line-numbers="1-6">
            final case class FeatureDef[D, Expr](inp: Input[D], op: Expr, name: String, partition: TimeWindow)
           </code></pre>

      </section>

      <section>
        <h3>And we can have complex input.</h3>
      </section>

      <!--Slide-->
      <section data-transition="fade-out">
        <pre><code class="hljs scala"  style="font-size:22px;" data-trim data-line-numbers="2">
            FeatureDef(
              dir("input_table").join(dir("another_table")).orElse(const("myTestData")),
              sum(when("browser" == "safari") 1 else 0),
              browser_safari_count
              0 ~ 14 days
            )
           </code></pre>
      </section>

      <!-- Slide 7 -->

      <section>
        <h6>And we can have a list of them</h6>
        <pre><code style="font-size:22px;" data-trim data-line-numbers="1-10" data-noescape>
          List(
            FeatureDef(dir("account"), sum(acc_bal)......),
            FeatureDef(dir("payments"), sum(debit).when(country == 'aus')......),
            FeatureDef(dir("account").join(dir("payments")), max(acc_bal)......),
            FeatureDef(const(data), min(acc_bal)......),
          )

         </code></pre>
      </section>

      <!-- Slide 5 -->

      <section>
        <h2>What next?</h2>
        <p style="font-size: 30px;">We should be able to compose programs.</p>
        <p class="frament" style="font-size: 30px;">An interface to use the list the way user needs.</p>
      </section>

      <section>
        <h3> Probably, we need sort of this kind of a usage pattern</h3>
        <pre><code class=" hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-100">
          val list: List[FeatureDef[D]] = ???

          def start(featureDef: FeatureDef[D]): FeatureGen[FeatureResult[D]] = ???

          // for instance, let's sequence it.
          val listOfWideTables: FeatureGen[List[FeatureRes[D]]] =
          list.map(start).sequence

          // and probably feed the list of wide tables to different ML
          val job: FeatureGen[List[D] =
          listOfWideTables.flatMap(regressionModel.train)

          </code></pre>

      </section>

      <!-- Slide 5 -->


      <!-- Slide 5 -->

      <section>
        <h2>Eyes on:</h2>
        <ul>
          <li>Effects: ZIO</li>
          <li>Semigroup</li>
          <li>Natural Transformation: The impl of abstraction into ZIO</li>
        </ul>
        <p>We use ZIO for a variety of reasons.</p>
      </section>

      <!-- Slide 6 -->

      <section>
        <h2> The mental model of ZIO </h2>
        <div>
          <pre><code class="hljs scala" data-trim>
                  ...
  
                    ZIO[R, E, A]
                    // ZIO[Environment, Error, Result]
                  ...
             </code></pre>

        </div>
        <div>
          <pre><code class="hljs scala" data-trim>
                  ...
  
                    R => Either[E, A]
  
                    // Given an input R,
                    // the computation either returns an Error or a result A.
                  ...
              </code></pre>
        </div>
      </section>


      <!-- Slide 8 -->

      <section>
        <section>
          <h3>The structure.</h3>
          <pre><code class="hljs scala" style="font-size:22px;width: 1200px;" data-line-numbers="1-10"  data-trim>
                  sealed trait FeatureGen[D, E, A] { self =>   
                    def <*>[B](feature2: FeatureGen[D, E, B]): FeatureGen[D, E, (A, B)] =
                      FeatureGen.Zip(self, feature2)
    
                    def map2[B, C](that: FeatureGen[D, E, B])(f: (A, B) => C): FeatureGen[D, E, C] =
                      (self zip that).map({ case (a, b) => f(a, b) })
                  
                    def map[B](f: A => B): FeatureGen[D, E, B] =
                      FeatureGen.Map(self, f)
                  }
                  </code></pre>
          </code></pre>
        </section>
        <section>
          <pre><code class="hljs scala" style="font-size:19px;" data-noescape>
                <p style="font-size:21px;text-align:left;"><span style="color: cadetblue;">D</span> is data</p>
            <p style="font-size:21px;text-align:left;"><span style="color: cadetblue;">E</span> is Expression that can operate on data</p>
            <p style="font-size:21px;text-align:left;"><span style="color: cadetblue;">A</span> is the result A</p>
          </code></pre>
        </section>
        <section>
          <pre><code class="hljs scala" style="font-size:19px;">
  final case class Pure[A](value: A) extends FeatureGen[Nothing, Nothing, A] 
  final case class Zip[D, E, A, B](f: FeatureGen[D, E, A], g: FeatureGen[D, E, B])
  final case class Map[D, E, A, B](feature1: FeatureGen[D, E, A], f: A => B) extends FeatureGen[D, E, B]
  final case class CreateFeatures[D, E](input: FeatureDef[D, E]) extends FeatureGen[D, E, FeatureRes[D]]
  final case class JoinFeatures[D, E](
    f1: FeatureGen[D, E, FeatureRes[D]], 
    f2: FeatureGen[D, E, FeatureRes[D]]
  ) extends FeatureGen[D, E, FeatureRes[D]]
            </code></pre>
        </section>
        <section data-transition="fade-out">
          <pre><code class="hljs scala" style="font-size:19px;" data-trim>
              def sequence[D, E, A](list: List[FeatureGen[D, E, A]]): FeatureGen[D, E, List[A]] = ???
            </code></pre>
        </section>
        <section data-transition="fade-in">
          <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="2" data-trim>
              def sequence[D, E, A](list: List[FeatureGen[D, E, A]]): FeatureGen[D, E, List[A]] = 
                list.foldLeft(FeatureGen.pure[D, Expr, List[A]](List.empty[A]))((aa, bb) => bb.map2(aa)(_ :: _))
                </code></pre>
        </section>
        <section>
          <h2>A one-time written implementation to ZIO</h2>
          <p>For this you need a richer target effect system </p>
          <pre><code class="hljs scala" style="font-size:19px;" data-trim>ZIO[DataOp.Service[D, Expr], AppError, A]</code></pre>
          <pre><code class="hljs scala" style="font-size:19px;" data-trim>
              def apply[A](fa: FeatureGen[D, Expr, A]): ZIO[DataOp.Service[D, Expr], Throwable, A] = ???
            </code></pre>

        </section>

        <section>
          <h2>A one-time written implementation to ZIO</h2>
          <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
      def apply[A](fa: FeatureGen[D, Expr, A]): ZIO[DataOp.Service[D, Expr], Throwable, A] =
        fa match {
          case Pure(value)      => ZIO.succeed(value)
          case Zip(pgm1, pgm2)  => apply(pgm1).zip(apply(pgm2))
          case Map(pgm, f)      => apply(pgm).map(f)
          case Fail(message)    => ZIO.fail(new AppError(message))
          ...
        }
    }
                </code></pre>
        </section>
        <section>
          <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
          ...
            case JoinFeatures(feature1, feature2) =>
            apply(feature1)
              .zip(apply(feature2))
              .flatMap({
                case (f1, f2) =>
                  ZIO.accessM[DataOp.Service[D, Expr]](
                    r => r.join(f1.value, f2.value).map(r => FeatureRes(r, f1.metadata ++ f2.metadata))
                  )
              })
            ...  
            </code></pre>

        </section>
        <section>
          <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
            case CreateFeatures(input) =>
              ZIO.accessM[DataOp.Service[D, Expr]](
                env =>
                  env
                    .get(input.input, input.forPartition)
                    .flatMap(res => {
                      env
                        .generateFeature(res, input)
                        .map(
                          r =>
                            FeatureRes(
                              r,
                              input.featuresLogic
                                .map(t => Metadata(FeatureName(t.name, input.forPartition), input.input.toString))
                            )
                        )
                    })
            )
          </code></pre>
        </section>

      </section>

      <!-- Slide 9 -->

      <section>
        <pre><code class="hljs scala">
def findRequests(
  x: FeatureGen[D, Expr, B]
 ): List[SMap[Source[D], List[Logic[Expr]]]] = ???
            </code></pre>
      </section>

      <!-- Slide 10 -->

      <section>
        <pre><code class="hljs scala" style="font-size:22px;">
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
    fa match {
      case CreateFeatures(featureDef) => ???
      case JoinFeatures(f1, f2) => ???
      case Pure(_)              => ???
      case Map(f1, _)           => ???
      case Zip(f1, f2)          => ???
      case Fail(_)              => ???
    }
}
            </code></pre>
      </section>


      <!-- Slide 11 - code0 -->

      <section data-transition="fade-out">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="7,8,9" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}

            </code></pre>
      </section>

      <!-- Slide 12 - code0 -->


      <section data-transition="fade-in">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="9,10" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
      </code></pre>
      </section>


      <!-- Slide 13 - code0 -->


      <section data-transition="fade-out">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="11" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}

            </code></pre>
      </section>

      <!-- Slide 14 - code0 -->


      <section data-transition="fade-in">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="12" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
      </section>


      <!-- Slide 15 - code0 -->

      <section data-transition="fade-out">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="13" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
      </section>

      <!-- Slide 16 - code0 -->

      <section data-transition="fade-in">
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="14" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
      </section>

      <!-- Slide -->

      <section>
        <h2> Results - Let's Flink </h2>
      </section>

      <!-- Slide -->
      <section>
        <h2>Let's define the set of features !</h2>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-100" data-noescape>
            List(
              FeatureDef(
                const(table),
                'accountBalance.sum,
                "sum_account_balance",
                0 ~ 2 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.max,
                "max_account_balance",
                0 ~ 2 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.sum,
                "sum_account_balance",
                2 ~ 4 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.max,
                "max_account_balance",
                2 ~ 4 weeks
              ),
              FeatureDef(
                const(table),
                'accountBalance.sum,
                "sum_account_balance",
                0 ~ 4 weeks,
                Some((a: Expression, b: Expression) => a + b)
              ),
              FeatureDef(
                const(table),
                'accountBalance.max,
                "max_account_balance",
                0 ~ 4 weeks,
                Some((a: Expression, b: Expression) => (a > b) ? (a, b))
              )
                          </code></pre>

      </section>

      <!-- Slide -->

      <section>
        <h4>Without Any Optimiser</h4>
        <video width="1000" height="680" controls>
          <source src="images/fully_unoptimised.mov" type="video/mp4">
        </video>
      </section>

      <!-- Slide -->
      <section>
        <h4> (Over) Simplified.. </h4>
        <img src="images/worst.png" width=1000 style="border: none;">
      </section>

      <!-- Slide -->

      <section>
        <h4>With Join Optimiser</h3>
          <video width="1000" height="680" controls>
            <source src="images/combineAllEffJoin.mov" type="video/mp4">
          </video>
      </section>

      <!-- Slide -->
      <section>
        <h4> Simplified.. </h4>
        <img src="images/divide_n_conquer.png" style="border: none;" width=800>
      </section>

      <!-- Slide -->

      <section>
        <h4>With Join and Aggregation Optimiser</h2>
          <video width="1000" height="680" controls>
            <source src="images/reduce_aggregations.mov" type="video/mp4">
          </video>
      </section>

      <!-- Slide -->
      <section>
        <h4> Simplified.. </h4>
        <img src="images/reduce_aggregation.png" style="border: none;" width=800>
      </section>

      <!-- Slide -->

      <section>
        <h4>With Join, Aggregation & Reuse Optimiser</h4>
        <video width="1000" height="600" controls>
          <source src="images/thbestplan.mov" type="video/mp4">
        </video>
      </section>

      <!-- Slide -->
      <section>
        <h4> Simplified.. </h4>
        <img src="images/thbestplan.png" style="border: none;" width=800>
      </section>

      <!-- Slide -->
      <section>
        <table>
          <tr>
            <th align="center">
              Before
            </th>
            <th align="center">
              After
            </th>
          </tr>
          <tr>
            <th>
              <img src="images/worst.png" style="border: none;" width=1000>
            </th>
            <th>
              <img src="images/thbestplan.png" style="border: none;" width=650>
            </th>
          </tr>
        </table>
      </section>

      <!-- Slide -->

      <section>
        <h4>Summary of FP principles</h4>

        The basic principle is that,
        by weakening the monadic interface to that of an
        applicative functor (or, more precisely, an alternative functor),
        it becomes possible to perform enough static
        analysis to compute first sets for productions.


      </section>

      <!-- Slide 20 -->
    </div>
  </div>

  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      // ...

      // The "normal" size of the presentation, aspect ratio will be preserved
      // when the presentation is scaled to fit different resolutions. Can be
      // specified using percentage units.
      width: 1300,
      height: 750,

      // Factor of the display size that should remain empty around the content
      margin: 0.1,

      // Bounds for smallest/largest possible scale to apply to content
      minScale: 0.2,
      maxScale: 1.5,
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true },
        { src: 'https://d3js.org/d3.v4.min.js' },
        { src: 'plugin/d3js/d3js.js' }
      ]
    });







  </script>
</body>

</html>