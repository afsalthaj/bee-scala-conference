<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/beige.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/magula.css">


  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);

  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <!-- Heading section -->
      <section data-markdown>
        <textarea data-template>
            ## FP meets Real world
	      </textarea>
      </section>

      <!-- Slide 2 -->
      <section>
        <h2>Why FP in Scala can make it hard ?</h2>
        <h6>At an application code level, should I be: </h6>
        <ul style="font-size:35px">
          <li>Dealing with free structures with boiler-plates</li>
          <li>Get hit with a ton of jargon and theory</li>
          <li>Implicits.</li>
          <li>Type inference.</li>
          <li>Early specialisations to standard type classes.</li>
          <li>In a lost state of possibly many solutions.</li>
        </ul>
        <p style="font-size:35px">Result is,
          <span style='color:maroon'> slower </span> development of
          <span style='color:maroon'> incomplete/FP-in-small </span> solutions
        </p>
      </section>


      <!-- Slide 3 -->

      <section>
        <h2>Sticking to fundamentals is the key</h2>
        <ul>
          <li>Referential transparency.</li>
          <li>Total functions</li>
          <li>Lawful structures - descriptions</li>
          <li>Type driven development.</li>
        </ul>
        <p> Result is,
          <strike style='color:maroon'> slower </strike> <span style='color:green'> faster </span> development of
          <strike style='color:maroon'> FP-in-small </strike> <span style='color:green'> pure FP </span> solutions.
        </p>
      </section>

      <!--Slide -->

      <section>
        <h3>Possible, if we have a proper structure or encoding of our application domain.</h3>
      </section>
      <!-- Slide -->

      <section>
        <h3 class="fragment grow">Let us write FP for a Bigdata problem </h3>
        <h6 class="fragment">Handling REAL WORLD requirements. </h6>
        <br>
      </section>

      <!-- Slide -->

      <section id="fragments">
        <h2>Problem - Context</h2>
        <p align="left" style="font-size:30px"> We have billions of events as clickstream of customers hitting banking
          applications.</p>
        <p align="left" style="font-size:30px"> We have millions of customer account data.</p>
        <p align="left" style="font-size:30px"> We have millions of payment datasets.</p>
        <p align="left" style="font-size:30px"> We use all of it to do business analysis and machine learning.</p>
      </section>
      <section>
        <h2>Problem - Requirements</h2>
        <p align="left" style="font-size:30px"> We need to find attributes of customers from big-data.</p>
        <p class="fragment" align="left" style="font-size:30px"> We call them <span style="color: cadetblue;">
            "features". </span> Example: total account transactions for a customer in last 3 weeks </p>
        <p class="fragment" align="left" style="font-size:30px"> Expose a light weight interface to quickly add new
          business logic. </p>
        <p class="fragment" align="left" style="font-size:30px"> Expose a thin API to combine them to
          form a wide table of features. </p>
        <p class="fragment" align="left" style="font-size:30px"> We further compose to form tens of hundreds of
          wide tables, feeding different ML algorithms for instance.
        </p>
      </section>
      <section>
        <h3>What does that mean for us?</h3>
        <p align="left" style="font-size:30px;color: black;"> That is a thin layer of interface to
          <span style="font-weight:900;color:red;">declaratively</span>
          define <span style="font-weight:900;color:red;">clear and concise</span> business logic / features - <span
            style="font-weight:900;color:red;">uncluttered</span> with
          <span style="font-weight: 900;color:red;">performance related details</span> </p>
        <p class="fragment" align="left" style="font-size:30px;color: black;"> Accompanied by an API that allows you to
          <span style="font-weight:800;color:red;">compose</span>
          each operations. </p>

        <p class="fragment" align="left" style="font-size:30px;"> Declarative, but <span
            style="font-weight:800;color:red;"> not </span> at the cost of <span style="font-weight:800;color:red;">
            performance </span>.</p>
        <p class="fragment" align="left" style="font-size:30px"><span
            style="font-weight:800;color:red;">Optimisations</span>, which is otherwise <span
            style="font-weight:800;color:red;">complex</span>
          with handwritten language of data-source.
        </p>
        <p class="fragment" align="left" style="font-size:30px;color: black;"> It should be
          <span style="font-weight:800;color:red;">fairly backend agnostic, testable and backed with laws.</span></p>
      </section>

      <section>
        <h3>But, we don't have a year to make it happen. </h3>
      </section>

      <!--Slide -->
      <section>
        <h2>A simple feature definition</h2>
        <h6> Find out sum of account balance of all customers in last 14 days.</h6>
      </section>

      <!-- Slide 18 -->

      <section data-transition="fade-out">
        <h2>A single feature definition is equivalent to</h2>
        <pre><code class="hljs sql" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          select
            customer_id,
            sum(coalesce(account_balance, 0)) 
            as "account_balance_0_14d"
          from 
          input_table
          group by customer_id
          where
            time < time_stamp() &&
            time >= minusDays(time_stamp(), 14)
        </code></pre>
        <p>Field <span style="color: cadetblue;"> "time" </span> represents partitions.</p>
      </section>

      <!-- Slide-->
      <section data-transition="fade-in">
        <h2>We could reduce it down to</h2>
        <pre><code class="hljs sql" style="font-size:22px;" data-trim data-line-numbers="3,4,6,10">
          select
            customer_id,
            sum(coalesce(account_balance, 0)) 
            as "account_balance_0_14d"
          from 
          input_table
          group by customer_id
          where
            time < time_stamp() &&
            time >= minusDays(time_stamp(), 14)
           </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>In short</h2>
        <pre><code class="hljs scala" style="font-size:25px;" data-trim data-line-numbers="1-10">
          ...

          sum(coalesce(account_balance, 0)) 
          as "account_balance_0_14d"
          from input_table of 0-14 days

          ...

       </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>(Minor) Fix feature name</h2>
        <pre><code class="hljs scala"  style="font-size:25px;" data-trim data-line-numbers="4">
                  ...
        
                  sum(coalesce(account_balance, 0)) 
                  as "account_balance_0_14d"
                  from input_table of 0-14 days
        
                  ...
               </code></pre>

      </section>

      <!--Slide -->
      <section data-transition="fade-out">
        <h2>(Minor) Fix feature name</h2>
        <pre><code class="hljs scala" style="font-size:25px;" data-trim data-line-numbers="4">
                        ...
              
                        sum(coalesce(account_balance, 0)) 
                        as "account_balance"
                        from input_table of 0-14 days
              
                        ...
                     </code></pre>

      </section>

      <!-- Slide -->
      <section data-transition="fade-out">
        <h2>Let's make it compile.</h2>
        <pre><code class="hljs scala" style="font-size:28px;" data-trim data-line-numbers="1-6">
          
          final case class FeatureDef[D, Expr](
            inp: Input[D], 
            op: Expr, 
            name: String, 
            partition: TimeWindow
        )
        
        </code></pre>

      </section>

      <section data-transition="fade-out">
        <h2>Input</h2>
        <pre><code class="hljs scala" style="font-size:22px;width: 1200px;" data-trim>
            
   sealed trait Input[D] { self =>     
     def orElse(input: Input[D]): Input[D] =
       Input.OrElse(self, input)
     }

    object Input {
      final case class Constant[D](value: D) extends Input[D]
      final case class Directory[D](input: String) extends Input[D]

      def dir[D](input: Input[D]): Input[D] = Directory(input)
      def const[D](input: Input[D]): Input[D] = Constant(input)
    }   
          </code></pre>

      </section>

      <!-- Slide -->
      <section data-transition="fade-out">
        <h2>Example of a FeatureDef.</h2>
        <pre><code class="hljs scala" style="font-size:28px;" data-trim data-line-numbers="1-6">
          FeatureDef(
            dir("input_table"),
            sum(coalesce(account_balance, 0)) 
            "account_balance"
            0 ~ 14 days
          )
         </code></pre>
      </section>

      <!--Slide-->
      <section data-transition="fade-out">
        <h3>With a complex input.</h3>
        <pre><code class="hljs scala"  style="font-size:25px;" data-trim data-line-numbers="2">
            FeatureDef(
              dir("input_table").join(dir("another_table")).orElse(const("myTestData")),
              sum(when("browser" == "safari") 1 else 0),
              browser_safari_count
              0 ~ 14 days
            )
           </code></pre>
      </section>

      <!-- Slide 7 -->

      <section>
        <h6>And we can have a list of them</h6>
        <pre><code style="font-size:22px;" data-trim data-line-numbers="1-10" data-noescape>
          List(
            FeatureDef(dir("account"), sum(acc_bal)......),
            FeatureDef(dir("payments"), sum(debit).when(country == 'aus')......),
            FeatureDef(dir("account").join(dir("payments")), max(acc_bal)......),
            FeatureDef(const(data), min(acc_bal)......),
          )

         </code></pre>
      </section>

      <!-- Slide 5 -->

      <section>
        <h3>Primitives and Combinators</h3>
        <h6>To begin with,</h6>
        <pre><code class=" hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-100">
            def start(featureDef: FeatureDef[D]): FeatureGen[FeatureRes[D]] = ???
  
            final case class FeatureRes[D](result: D, metadata: Metadata) 
            final case class Metadata(list: List[FeatureDetails])
            final case class FeatureDetails(name: FeatureName, sources: Vector[String])
            </code></pre>
      </section>

      <!-- Slide 8 -->

      <section>
        <h3>The structure.</h3>
        <pre><code class="hljs scala" style="font-size:22px;width: 1200px;" data-line-numbers="1-10"  data-trim>
                  sealed trait FeatureGen[D, E, A] { self =>   
                    def <*>[B](feature2: FeatureGen[D, E, B]): FeatureGen[D, E, (A, B)] =
                      FeatureGen.Zip(self, feature2)
    
                    def map2[B, C](that: FeatureGen[D, E, B])(f: (A, B) => C): FeatureGen[D, E, C] =
                      (self zip that).map({ case (a, b) => f(a, b) })
                  
                    def map[B](f: A => B): FeatureGen[D, E, B] =
                      FeatureGen.Map(self, f)
                  }
                  </code></pre>
        </code></pre>
      </section>
      <section>
        <pre><code class="hljs scala" style="font-size:19px;" data-noescape data-trim>
                <p style="font-size:26px;text-align:center;"><span style="color: cadetblue;">D</span> is data</p>
            <p style="font-size:26px;text-align:center;"><span style="color: cadetblue;">E</span> is Expression that can operate on data</p>
            <p style="font-size:26px;text-align:center;"><span style="color: cadetblue;">A</span> is the result of the computation.</p>
          </code></pre>
      </section>
      <section>

        <pre><code class="hljs scala" style="font-size:19px;">
  final case class Pure[A](value: A) extends FeatureGen[Nothing, Nothing, A]
  
  final case class Zip[D, E, A, B](f: FeatureGen[D, E, A], g: FeatureGen[D, E, B]) extends FeatureGen[D, Expr, (A, B)]

  final case class Map[D, E, A, B](feature1: FeatureGen[D, E, A], f: A => B) extends FeatureGen[D, E, B]

  final case class CreateFeatures[D, E](input: FeatureDef[D, E]) extends FeatureGen[D, E, FeatureRes[D]]

  final case class JoinFeatures[D, E](
    f1: FeatureGen[D, E, FeatureRes[D]], 
    f2: FeatureGen[D, E, FeatureRes[D]]
  ) extends FeatureGen[D, E, FeatureRes[D]]
            </code></pre>
      </section>
      <section>
        <h4>Our helper functions</h4>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim>

          def start[D, Expr, A](defn: FeatureDef[D, Expr]) =
            CreateFeatures(defn)

          def pure[D, Expr, A](value: => A) =
            FeatureGen.Pure(value)

          def fail[A](message: String) =
            FeatureGen.Fail(message)

          def join[D, Expr,](f1: FeatureGen[D, Expr, FeatureRes[D]], f2: FeatureGen[D, Expr, FeatureRes[D]]) =
            FeatureGen.Join(f1, f2)

          def combineAll[D, Expr. A](computations: ::[FeatureGen[D, Expr, FeatureRes[D]]]) = 
            computations.reduce(a, b => join(a, b))          
        </code></pre>
      </section>

      <section data-transition="fade-out">
        <h3>Sequence / Traverse </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim>
              def sequence[D, E, A](list: List[FeatureGen[D, E, A]]): FeatureGen[D, E, List[A]] = 
                list.foldLeft(pure[List[A]](Nil))((aa, bb) => bb.map2(aa)(_ :: _))

              def collectAll(list: List[FeatureGen[D, E, A]]): FeatureGen[D, E, List[A]] = 
                sequence(list)  
            </code></pre>
      </section>

      <!--Sections grouped together; Start-->
      <section data-transition="fade-out">
        <h3>Composing....</h3>
        <pre><code class=" hljs scala" style="font-size:24px; align-items: center;" data-line-numbers="1000" data-trim data-noescape>  
              val aJob: FeatureGen[FeatureResult[D]] = 
                start(defn)

              val joined = job1.join(job2).join(job3)

              val result = FeatureGen.collectAll(job1.join(job2).join(job3), job4, job5)    
              
              val anotherResult = FeatureGen.combineAll(List(job6, job7, job8, jb9))

              anotherResult.map(_.metadata.size)

              // and so forth

              </code></pre>
      </section>

      <section data-transition="fade-out">
        <h3>Composing....</h3>
        <pre><code class=" hljs scala" style="font-size:24px; align-items: center;" data-line-numbers="1,2" data-trim data-noescape>  
                val aJob: FeatureGen[FeatureResult[D]] = 
                  start(defn)
                
                val joined = job1.join(job2).join(job3)
                
                val result = FeatureGen.collectAll(job1.join(job2).join(job3), job4, job5)    
                
                val anotherResult = FeatureGen.combineAll(List(job6, job7, job8, jb9))
  
                anotherResult.map(_.metadata.size)
  
                // and so forth
  
                </code></pre>
      </section>

      <section data-transition="fade-out">
        <h3>Composing....</h3>
        <pre><code class=" hljs scala" style="font-size:24px; align-items: center;" data-line-numbers="4" data-trim data-noescape>  
                  val aJob: FeatureGen[FeatureResult[D]] = 
                    start(defn)

                  val joined = job1.join(job2).join(job3)

                  val result = FeatureGen.collectAll(job1.join(job2).join(job3), job4, job5)    
                  
                  val anotherResult = FeatureGen.combineAll(List(job6, job7, job8, jb9))
    
                  anotherResult.map(_.metadata.size)
    
                  // and so forth
    
                  </code></pre>
      </section>

      <section data-transition="fade-out">
        <h3>Composing....</h3>
        <pre><code class=" hljs scala" style="font-size:24px; align-items: center;" data-line-numbers="6" data-trim data-noescape>  
                    val aJob: FeatureGen[FeatureResult[D]] = 
                      start(defn)

                    val joined = job1.join(job2).join(job3)
      
                    val result = FeatureGen.collectAll(job1.join(job2).join(job3), job4, job5)    
                    
                    val anotherResult = FeatureGen.combineAll(List(job6, job7, job8, jb9))
      
                    anotherResult.map(_.metadata.size)
      
                    // and so forth
      
                    </code></pre>
      </section>

      <section data-transition="fade-out">
        <h3>Composing....</h3>
        <pre><code class=" hljs scala" style="font-size:24px; align-items: center;" data-line-numbers="8,9" data-trim data-noescape>  
                      val aJob: FeatureGen[FeatureResult[D]] = 
                        start(defn)

                      val joined = job1.join(job2).join(job3)
        
                      val result = FeatureGen.collectAll(job1.join(job2).join(job3), job4, job5)    
                      
                      val anotherResult = FeatureGen.combineAll(List(job6, job7, job8, jb9))
        
                      anotherResult.map(_.metadata.size)
        
                      // and so forth
        
                      </code></pre>
      </section>

      <section data-transition="fade-out">
        <h3>Composing....</h3>
        <pre><code class=" hljs scala" style="font-size:24px; align-items: center;" data-line-numbers="10" data-trim data-noescape>  
                        val aJob: FeatureGen[FeatureResult[D]] = 
                          start(defn)
  
                        val joined = job1.join(job2).join(job3)
          
                        val result = FeatureGen.collectAll(job1.join(job2).join(job3), job4, job5)    
                        
                        val anotherResult = FeatureGen.combineAll(List(job6, job7, job8, jb9))
          
                        anotherResult.map(_.metadata.size)
          
                        // etc
          
                        </code></pre>
      </section>

      <!--Sections grouped together; Start-->

      <!-- Slide 5 -->

      <section>
        <h2>Run <span style="color: red;">FeatureGen</span></h2>
        <p align="left" style="font-size:30px;color: black;"> Have a single function that runs FeatureGen to a target
          effect. </p>

        <p align="left" style="font-size:30px;color: black;"> We prefer to have an effect system that's maximum
          expressive in its types. </p>

        <p align="left" style="font-size:30px;color: black;"> In other words, we can't keep traversing through
          FeatureGen to plug new backends/test-services </p>
      </section>

      <section data-background="images/ZIO.png" data-state="dimbg">
        <h2>Going forward, We are using ZIO</h2>
        <ul>
          <li>No implicit requirements at user site</li>
          <li>Relatively straight forward concurrency operations</li>
          <li>Inbuilt expressive types with error channels.</li>
          <li>Awesome type inference</li>
        </ul>
      </section>

      <!-- Slide 6 -->
      <section data-background="images/ZIO.png" data-state="dimbg">
        <h2> The mental model of ZIO </h2>
        <div>
          <pre><code class="hljs scala" style="font-size:28px; align-items: center;" data-trim>
                  ...
  
                    ZIO[R, E, A]
                    // ZIO[Environment, Error, Result]
                  ...
             </code></pre>

        </div>
        <div>
          <pre><code class="hljs scala"  style="font-size:28px; align-items: center;" data-trim>
                  ...
  
                    R => Either[E, A]
  
                    // Given an input R,
                    // the computation either returns an Error or a result A.
                  ...
              </code></pre>
        </div>
      </section>

      <section>
        <h2>Run implementation of ZIO</h2>
        <pre><code class=" hljs scala" style="font-size:26px; align-items: center;"  data-noescape>
  type AnalyticsTask[D, Expr, A] = ZIO[DataService[D, Expr], AppError, A] 

  type Impl[D, Expr, A] = FeatureGen[D, Expr, A]) => AnalyticsTask[A]

  def run[D, Expr, A]: Impl[D, Expr, A] = ??? 

            </code></pre>
      </section>
      <section>
        <h3>Where, <span style="color: red;">Dataservice</span> is</h3>
        <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
            trait DataService[D, Expr] {
              def get(input: Input[D], partition: Option[Window]): Task[D]
              def generateFeature(d: D, featureRequest: FeatureDef[D, Expr]): Task[D]
              def join(left: D, right: D): Task[D]
              def projectFeatures(d: D, value: List[Logic[Expr]]): Task[D]
            }
              </code></pre>
      </section>
      <section>
        <h2>With that, Let's write RUN </h2>
        <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
        def run[D, Expr, A]: FeatureGen[D, Expr, A] => AnalyticsTask[A] = 
          fa =>
            def apply[A](fa: FeatureGen[D, Expr, A]): AnalyticsTask[A] = {
              fa match {
                case Pure(value)      => ZIO.succeed(value)
                case Zip(pgm1, pgm2)  => apply(pgm1).zip(apply(pgm2))
                case Map(pgm, f)      => apply(pgm).map(f)
                case Fail(message)    => ZIO.fail(new AppError(message))
                ... // In next slides
              }

          apply(fa)
        }
       }
                </code></pre>
      </section>
      <section>
        <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
          ...
            case JoinFeatures(feature1, feature2) =>
            apply(feature1)
              .zip(apply(feature2))
              .flatMap({
                case (f1, f2) =>
                  ZIO.accessM[DataOp.Service[D, Expr]](
                    r => r.join(f1.value, f2.value).map(r => FeatureRes(r, f1.metadata ++ f2.metadata))
                  )
              })
            ...  
            </code></pre>

      </section>
      <section>
        <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
            case CreateFeatures(input) =>
              ZIO.accessM(service =>
                env.generateFeature(input.data, input.logic, input.partition)
                  .map(r =>
                    FeatureRes(result, input.logic.map(t => Metadata(FeatureName(t.name, input.forPartition), input.input.toString)))
                  )
              })
            )
          </code></pre>
      </section>
      <section>
        <h3>Let' kick this off with Flink</h3>
        <p>A Flink DataService, which is only a 12 line code.</p>
        <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-10" data-trim>
              val flinkSerive = new DataService[flink.Table, flink.Expression] {
                def get(input: Input[D], partition: Option[TimeWindow]): Task[Table] = ???
                def generateFeature(d: Table, featureRequest: FeatureDef[Table, Expression]): Task[Table] = ???
                def join(left: Table, right: Table): Task[Table] = ???
                def projectFeatures(d: D, value: List[Logic[Expression]]): Task[Table] = ????
              }
            </code></pre>
      </section>
      <section>
        <h3>And Running them is as easy as!</h3>

        <pre><code class="hljs scala" style="font-size:28px;" data-trim>
            val job: FeatureGen[Table, Expression] = ???
            run(job).provide(flinkService)

              </code></pre>
      </section>
      <section>
        <h2>Let's define the set of features !</h2>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-100" data-noescape>
                List(
                  FeatureDef(
                    const(table),
                    'accountBalance.sum,
                    "sum_account_balance",
                    0 ~ 2 weeks
                  ),
                  FeatureDef(
                    const(table),
                    'accountBalance.max,
                    "max_account_balance",
                    0 ~ 2 weeks
                  ),
                  FeatureDef(
                    const(table),
                    'accountBalance.sum,
                    "sum_account_balance",
                    2 ~ 4 weeks
                  ),
                  FeatureDef(
                    const(table),
                    'accountBalance.max,
                    "max_account_balance",
                    2 ~ 4 weeks
                  ),
                  FeatureDef(
                    const(table),
                    'accountBalance.sum,
                    "sum_account_balance",
                    0 ~ 4 weeks
                  ),
                  FeatureDef(
                    const(table),
                    'accountBalance.max,
                    "max_account_balance",
                    0 ~ 4 weeks
                  )
          </code></pre>

        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-line-numbers="1-100" data-noescape>
               FeatureGen.combineAll(features.map(start))      
          </code></pre>

      </section>
      <section>
        <h4>Without Any Optimiser</h4>
        <video width="1000" height="680" controls>
          <source src="images/fully_unoptimised.mov" type="video/mp4">
        </video>
      </section>

      <!-- Slide -->
      <section>
        <h3> A Simplified version. </h3>
        <img src="images/worst.png" width=1000 style="border: none;">
      </section>


      <section>
        <h3>We hit the first real world.</h3>
        <p>An execution plan that is worst in all sense.</p>
        <p> We saw, joins are sequential. </p>
      </section>

      <!--Slide-->
      <section>
        <h3> Can our abstraction solve this ?</h3>
        <pre><code class="hljs scala" style="font-size:19px;" data-line-numbers="1-1000" data-trim>
              def combineAllEff[D, Expr](list: List[FeatureGen[D, Expr, FeatureRes[D]]]): FeatureGen[D, Expr, FeatureRes[D]] = {
                val result = list
                  .sliding(2, 2)
                  .toList
                  .map(r => {
                    (r.headOption, r.lift(1)) match {
                      case (Some(a), Some(b)) => a.join(b)
                      case (Some(a), None)    => a
                      case (None, Some(a))    => a
                      case (None, None)       => fail("Empty list")
                    }
                  })
            
                result match {
                  case h :: Nil => h
                  case ll       => combineAllEff(ll)
                }
              }
                </code></pre>

      </section>

      <!--Slide-->
      <section>
        <h4>With The Quick Fix On!</h3>
          <video width="1000" height="680" controls>
            <source src="images/combineAllEffJoin.mov" type="video/mp4">
          </video>
          <pre><code class="hljs scala" style="font-size:22px;"  data-noescape>
                FeatureGen.<style="font-color:red">CombineAllEff</style>(features.map(start))      
           </code></pre>
      </section>

      <!-- Slide -->
      <section>
        <h4>The simplified execution plan</h4>
        <img src="images/divide_n_conquer.png" style="border: none;" width=800>
      </section>

      <!-- Slide 9 -->
      <section data-transition="fade-out">
        <h3> Are we done yet ? </h3>
        <h6 style="color:red">We could reduce the number of joins</h6>
        <pre><code class="hljs scala" style="font-size:19px;" data-noescape>
              case class Join[D, E, A](computation1, computation2) extends FeatureGen[D, E, A]      
            </code></pre>
      </section>

      <section data-transition="fade-out">
        <h3> Are we done yet ? </h3>
        <h6 style="color:red">We could reduce the number of joins</h6>
        <pre><code class="hljs scala" style="font-size:19px;" data-noescape>
  case class Join[D, E, A](computation1 & computation2, <strike style='color:maroon'>computation2</strike>) extends FeatureGen[D, E, A]      
           </code></pre>
      </section>

      <section>
        <h3>Grab all <span style="color:red">Feature-Requests</span> of <span style="color:red"> FeatureGen</span> </h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-noescape>
              def listOfFeatureRequests(
                pgm: FeatureGen[D, Expr, B]
              ): FeatureRequests[D, Expr] = ???
              </code></pre>
      </section>

      <section>
        <h3>Wide Table</h3>
        <pre><code class="hljs scala" style="font-size:19px;" data-trim data-noescape>
                final case class WideTable[D, Expr](map: Map[(Input, TimeWindow), List[Logic[Expr]]]) { self =>
                  def merge(that: WideTable[D, Expr])                    = WideTable(self.map |+| that.map)
                  ...
                  def execute: FeatureGen[D, Expr, FeatureRes[D]] =
                    FeatureGen.combineAllEff(
                      map.map({ case (a, b) => CreateFeatures(FeatureDef(a.input, b, a.forPartition)) }).toList
                    )
                }
              </code></pre>
      </section>
      <section>
        <h3>FeatureRequests</h3>
        <pre><code class="hljs scala" style="font-size:19px;" data-trim data-noescape>
                  
  final case class FeatureRequests[D, Expr](list: List[WideTable[D, Expr]]) { self =>
    def ++(that: FeatureRequests[D, Expr]): FeatureRequests[D, Expr] =
      FeatureRequests(self.list ++ that.list)
  
    def merge(that: FeatureRequests[D, Expr]): FeatureRequests[D, Expr] =
      FeatureRequests((self.list |@| that.list)(_ merge _))
  }
  
                </code></pre>
      </section>

      <!--Slide 10-->
      <section data-transition="fade-out">
        <h3>Grab all <span style="color:red">Feature-Requests</span> of <span style="color:red"> FeatureGen</span>
          program</h3>

        <pre><code class="hljs scala" style="font-size:19px;"data-line-numbers="1000"  data-trim data-noescape>
              def listOfFeatureRequests[D, E, A](fa: FeatureGen[D, E, A]): FeatureRequests[D, E] = {
                def loop[B](
                  value: FeatureGen[D, E, B],
                  requests: FeatureRequests[D, E]
                ): FeatureRequests[D, E] =
                  value match {
                    case CreateFeatures(featureDef) =>
                      requests.add(WideTable.fromFeatureDef[D, E](featureDef))
            
                    case JoinFeatures(f1, f2) => loop(f1, requests).merge(loop(f2, requests))
                    case Pure(_)              => requests
                    case Map(f1, _)           => loop(f1, requests)
                    case Zip(f1, f2)          => loop(f1, requests) ++ loop(f2, requests)
                    case Fail(_)              => requests
                  }
            
                loop(fa, FeatureRequests.make[D, E])
              }
            
            </code></pre>

      </section>

      <section data-transition="fade-out">
        <h3>Grab all <span style="color:red">Feature-Requests</span> of <span style="color:red"> FeatureGen</span>
          program</h3>
        of some <span style="color:red">WideTable</span></p>
        <pre><code class="hljs scala" style="font-size:19px;"data-line-numbers="7,8"  data-trim data-noescape>
                      def listOfFeatureRequests[D, E, A](fa: FeatureGen[D, E, A]): FeatureRequests[D, E] = {
                        def loop[B](
                          value: FeatureGen[D, E, B],
                          requests: FeatureRequests[D, E]
                        ): FeatureRequests[D, E] =
                          value match {
                            case CreateFeatures(featureDef) =>
                              requests.add(WideTable.fromFeatureDef[D, E](featureDef))
                    
                            case JoinFeatures(f1, f2) => loop(f1, requests).merge(loop(f2, requests))
                            case Pure(_)              => requests
                            case Map(f1, _)           => loop(f1, requests)
                            case Zip(f1, f2)          => loop(f1, requests) ++ loop(f2, requests)
                            case Fail(_)              => requests
                          }
                    
                        loop(fa, FeatureRequests.make[D, E])
                      }
                    
                    </code></pre>

      </section>


      <section data-transition="fade-out">
        <h3>Grab all <span style="color:red">Feature-Requests</span> of <span style="color:red"> FeatureGen</span>
          program</h3>
        <p style="font-size: 25px;">A vague assumption that <span style="color:red">FeatureRequests</span> is a list
          of some <span style="color:red">WideTable</span></p>
        <pre><code class="hljs scala" style="font-size:19px;"data-line-numbers="10"  data-trim data-noescape>
                        def listOfFeatureRequests[D, E, A](fa: FeatureGen[D, E, A]): FeatureRequests[D, E] = {
                          def loop[B](
                            value: FeatureGen[D, E, B],
                            requests: FeatureRequests[D, E]
                          ): FeatureRequests[D, E] =
                            value match {
                              case CreateFeatures(featureDef) =>
                                requests.add(WideTable.fromFeatureDef[D, E](featureDef))
                      
                              case JoinFeatures(f1, f2) => loop(f1, requests).merge(loop(f2, requests))
                              case Pure(_)              => requests
                              case Map(f1, _)           => loop(f1, requests)
                              case Zip(f1, f2)          => loop(f1, requests) ++ loop(f2, requests)
                              case Fail(_)              => requests
                            }
                      
                          loop(fa, FeatureRequests.make[D, E])
                        }
                      
                      </code></pre>

      </section>
      <section data-transition="fade-out">
        <h3>Grab all <span style="color:red">Feature-Requests</span> of <span style="color:red"> FeatureGen</span>
          program</h3>
        <p style="font-size: 25px;">A vague assumption that <span style="color:red">FeatureRequests</span> is a list
          of some <span style="color:red">WideTable</span></p>
        <pre><code class="hljs scala" style="font-size:19px;"data-line-numbers="11"  data-trim data-noescape>
                      def listOfFeatureRequests[D, E, A](fa: FeatureGen[D, E, A]): FeatureRequests[D, E] = {
                        def loop[B](
                          value: FeatureGen[D, E, B],
                          requests: FeatureRequests[D, E]
                        ): FeatureRequests[D, E] =
                          value match {
                            case CreateFeatures(featureDef) =>
                              requests.add(WideTable.fromFeatureDef[D, E](featureDef))
                    
                            case JoinFeatures(f1, f2) => loop(f1, requests).merge(loop(f2, requests))
                            case Pure(_)              => requests
                            case Map(f1, _)           => loop(f1, requests)
                            case Zip(f1, f2)          => loop(f1, requests) ++ loop(f2, requests)
                            case Fail(_)              => requests
                          }
                    
                        loop(fa, FeatureRequests.make[D, E])
                      }
                    
                    </code></pre>

      </section>
      <section data-transition="fade-out">
        <h3>Grab all <span style="color:red">Feature-Requests</span> of <span style="color:red"> FeatureGen</span>
          program</h3>
        <p style="font-size: 25px;">A vague assumption that <span style="color:red">FeatureRequests</span> is a list
          of some <span style="color:red">WideTable</span></p>
        <pre><code class="hljs scala" style="font-size:19px;"data-line-numbers="12"  data-trim data-noescape>
                        def listOfFeatureRequests[D, E, A](fa: FeatureGen[D, E, A]): FeatureRequests[D, E] = {
                          def loop[B](
                            value: FeatureGen[D, E, B],
                            requests: FeatureRequests[D, E]
                          ): FeatureRequests[D, E] =
                            value match {
                              case CreateFeatures(featureDef) =>
                                requests.add(WideTable.fromFeatureDef[D, E](featureDef))
                      
                              case JoinFeatures(f1, f2) => loop(f1, requests).merge(loop(f2, requests))
                              case Pure(_)              => requests
                              case Map(f1, _)           => loop(f1, requests)
                              case Zip(f1, f2)          => loop(f1, requests) ++ loop(f2, requests)
                              case Fail(_)              => requests
                            }
                      
                          loop(fa, FeatureRequests.make[D, E])
                        }
                      
                      </code></pre>

      </section>
      <section data-transition="fade-out">
        <h3>Grab all <span style="color:red">Feature-Requests</span> of <span style="color:red"> FeatureGen</span>
          program</h3>
        <p style="font-size: 25px;">A vague assumption that <span style="color:red">FeatureRequests</span> is a list
          of some <span style="color:red">WideTable</span></p>
        <pre><code class="hljs scala" style="font-size:19px;"data-line-numbers="13"  data-trim data-noescape>
                          def listOfFeatureRequests[D, E, A](fa: FeatureGen[D, E, A]): FeatureRequests[D, E] = {
                            def loop[B](
                              value: FeatureGen[D, E, B],
                              requests: FeatureRequests[D, E]
                            ): FeatureRequests[D, E] =
                              value match {
                                case CreateFeatures(featureDef) =>
                                  requests.add(WideTable.fromFeatureDef[D, E](featureDef))
                        
                                case JoinFeatures(f1, f2) => loop(f1, requests).merge(loop(f2, requests))
                                case Pure(_)              => requests
                                case Map(f1, _)           => loop(f1, requests)
                                case Zip(f1, f2)          => loop(f1, requests) ++ loop(f2, requests)
                                case Fail(_)              => requests
                              }
                        
                            loop(fa, FeatureRequests.make[D, E])
                          }
                        
                        </code></pre>

      </section>
      <section data-transition="fade-out">
        <h3>Grab all <span style="color:red">Feature-Requests</span> of <span style="color:red"> FeatureGen</span>
          program</h3>
        <p style="font-size: 25px;">A vague assumption that <span style="color:red">FeatureRequests</span> is a list
          of some <span style="color:red">WideTable</span></p>
        <pre><code class="hljs scala" style="font-size:19px;"data-line-numbers="14"  data-trim data-noescape>
                            def listOfFeatureRequests[D, E, A](fa: FeatureGen[D, E, A]): FeatureRequests[D, E] = {
                              def loop[B](
                                value: FeatureGen[D, E, B],
                                requests: FeatureRequests[D, E]
                              ): FeatureRequests[D, E] =
                                value match {
                                  case CreateFeatures(featureDef) =>
                                    requests.add(WideTable.fromFeatureDef[D, E](featureDef))
                          
                                  case JoinFeatures(f1, f2) => loop(f1, requests).merge(loop(f2, requests))
                                  case Pure(_)              => requests
                                  case Map(f1, _)           => loop(f1, requests)
                                  case Zip(f1, f2)          => loop(f1, requests) ++ loop(f2, requests)
                                  case Fail(_)              => requests
                                }
                          
                              loop(fa, FeatureRequests.make[D, E])
                            }
                          
                          </code></pre>

      </section>

      <!--Slide 10-->
      <section data-transition="fade-out">
        <h3<>We will manipulate existing implementation of FeatureGen.</h3>
          <pre><code class="hljs scala" style="font-size:19px;" data-trim data-noescape>
                  private def optimiser[D, Expr, A](
                    list: FeatureRequests[D, Expr]
                    impl: FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A]
                  ): FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A] = ???
                             
              </code></pre>
      </section>
      <section data-transition="fade-out">
        <h3<>We will manipulate existing implementation of FeatureGen.</h3>
          <pre><code class="hljs scala" style="font-size:19px;" data-trim data-noescape>
                  private def optimiser[D, Expr, A](
                    list: FeatureRequests[D, Expr]
                    impl: FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A]
                  ): FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A] = fa => {
                    ZIO
                      .collectAll(list.map(wideTable => impl(wideTable.execute)))
                      .flatMap(createdFeatures => ...
                             
              </code></pre>
      </section>
      <section data-transition="fade-out">
        <h3<>We will manipulate existing implementation of FeatureGen.</h3>
          <pre><code class="hljs scala" style="font-size:19px;" data-trim data-noescape>
                    private def optimiser[D, Expr, A](
                      list: FeatureRequests[D, Expr]
                      impl: FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A]
                    ): FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A] = fa => {
                      ZIO
                        .collectAll(list.map(wideTable => impl(wideTable.execute)))
                        .flatMap(createdFeatures => {
                          type Env = (Ref[SMap[Int, FeatureRes[D]]], DataOp.Service[D, Expr])
                          val result: FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A]  = ???
                               
                </code></pre>
      </section>
      <section data-transition="fade-out">
        <h3<>We will manipulate existing implementation of FeatureGen.</h3>
          <pre><code class="hljs scala" style="font-size:19px;" data-trim data-noescape>
                      private def optimiser[D, Expr, A](
                        list: FeatureRequests[D, Expr]
                        impl: FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A]
                      ): FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A] = fa => {
                        ZIO
                          .collectAll(list.map(wideTable => impl(wideTable.execute)))
                          .flatMap(createdFeatures => {
                            type Env = (Ref[SMap[Int, FeatureRes[D]]], DataOp.Service[D, Expr])
                            val result: FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A]  = {
                                case CreateFeatures(input) =>
                                  ZIO.accessM({case(state, service) =>
                                    state.get.flatMap(
                                        _.get(input.index).flatMap(_.containsFeatures(input.getFeatureNames)) match {
                                        // The wide table that consist of the required features is already used.
                                        case Some(_) =>
                                          impl(fail("Wide table is already used."))
                                        case None =>
                                         createdFeatures.get(input.index).flatMap(state.update)
                                    )
                                 
                  </code></pre>
      </section>
      <section>
        <h3>This implies, the two computations to be joined may not give results always.</h3>
        <p style="font-size:35px">Result is, join is converted to noop </p>
        <pre><code class="hljs scala" style="font-size:19px;" data-trim data-noescape>
                          case JoinFeatures(f1, f2) =>
                            apply(f1).either
                              .zip(apply(f2).either)
                              .flatMap({
                                case (Right(v1), Right(v2)) =>
                                  impl(join(pure(v1), pure(v2)))
                                case (Left(_), Right(v2)) =>
                                  impl(pure(v2))
                                case (Right(v1), Left(_)) =>
                                  impl(pure(v1))
                                case (Left(_), Left(_)) =>
                                  impl(fail("undefined state"))
                              })
              </code></pre>

      </section>
      <!-- Slide 16 - code0 -->

      <!-- Slide -->

      <section>
        <h2> Let's run again.</h2>
        <pre><code class="hljs scala" style="font-size:19px;" data-trim data-noescape>

        def newImpl(
        impl: FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A]
        ): FeatureGen[D, Expr, A] => AnalyticsTask[D, Expr, A] =
        fa => optimise(listOfFeatureGen(fa), fa)
      </code></pre>

      </section>

      <!-- Slide -->
      <section>
        <h4> Previous Execution Plan </h4>
        <img src="images/divide_n_conquer.png" style="border: none;" width=800>
      </section>

      <section>
        <h4>With Join and Aggregation Optimiser</h2>
          <video width="1000" height="680" controls>
            <source src="images/reduce_aggregations.mov" type="video/mp4">
          </video>
      </section>

      <!-- Slide -->
      <section>
        <h4> Simplified.. </h4>
        <img src="images/reduce_aggregation.png" style="border: none;" width=800>
      </section>

      <!-- Slide -->
      <section data-transition="fade-out">
        <h3> Are we done yet ? </h3>
        <h6 style="color:red">We could reuse the features.</h6>
        <pre><code class="hljs scala" style="font-size:19px;" data-noescape>
              TBD
              </code></pre>
      </section>
      <section>
        <h4>With Join, Aggregation & Reuse Optimiser</h4>
        <video width="1000" height="600" controls>
          <source src="images/thbestplan.mov" type="video/mp4">
        </video>
      </section>

      <!-- Slide -->
      <section>
        <h4> Simplified.. </h4>
        <img src="images/thbestplan.png" style="border: none;" width=800>
      </section>

      <!-- Slide -->
      <section>
        <table>
          <tr>
            <th align="center">
              Before
            </th>
            <th align="center">
              After
            </th>
          </tr>
          <tr>
            <th>
              <img src="images/worst.png" style="border: none;" width=1000>
            </th>
            <th>
              <img src="images/thbestplan.png" style="border: none;" width=650>
            </th>
          </tr>
        </table>
      </section>

      <!-- Slide -->

      <section>
        <h4>Summary</h4>

        WIP

      </section>

      <!-- Slide 20 -->
    </div>
  </div>

  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      // ...

      // The "normal" size of the presentation, aspect ratio will be preserved
      // when the presentation is scaled to fit different resolutions. Can be
      // specified using percentage units.
      width: 1300,
      height: 750,

      // Factor of the display size that should remain empty around the content
      margin: 0.1,

      // Bounds for smallest/largest possible scale to apply to content
      minScale: 0.2,
      maxScale: 1.5,
      history: true,
      hash: true,
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true },
        { src: 'https://d3js.org/d3.v4.min.js' },
        { src: 'plugin/d3js/d3js.js' }
      ]
    });
  </script>
</body>

</html>