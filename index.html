<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/beige.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">


    <!-- Printing and PDF exports -->
    <script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-markdown>
				    <textarea data-template>
                      ## FP meets Real world
				    </textarea>
        </section>


        <section>
            <h2>Why FP in Scala can make it hard ?</h2>
            <p>For an application code, should I be dealing with: </p>
            <ul style="font-size:35px">
                <li>Magical implicits.</li>
                <li>Free structures with boiler-plates</li>
                <li>Lifting error types everywhere - yes, type inference.</li>
                <li>Typeclass specialisations.</li>
                <li>Relatively complex code design and larger surface area</li>
            </ul>
            <p style="font-size:35px">Result is slower development of (incomplete) solutions</p>
        </section>


        <section>
            <h2>Sticking on to fundamentals is the key</h2>
            <ul>
                <li>Total functions</li>
                <li>Programs as descriptions.</li>
                <li>Referential transparency.</li>
                <li>Type driven development.</li>
                <li>Testability / Lawful / Less bugs</li>
            </ul>
            <p> Result is, faster development of high quality solutions.</p>
        </section>


        <section>
            <h2> Hence we have, and we need</h2>
            <ul>
                <li>Quick addition of new capabilities</li>
                <li>Resource safety</li>
                <li>Optimisations</li>
                <li>Performance</li>
                <li>Testability / Separation of concerns</li>
                <li>Intuitive error handling, and AOP style logging</li>
                <li>All of them should compose ...</li>
            </ul>
        </section>


        <section>
            <h2>So, before we deep dive</h2>
            <ul>
                <li>Effects: ZIO</li>
                <li>Semigroup</li>
                <li>Natural Transformation: The impl of abstraction into ZIO</li>
            </ul>
            <p>We use ZIO for a variety of reasons.</p>
        </section>


        <section>
            <h2> The mental model of ZIO </h2>
            <div>
            <pre><code class="hljs scala" data-trim>
                ...

                  ZIO[R, E, A]
                  // ZIO[Environment, Error, Result]
                ...
           </code></pre>

            </div>
            <div>
            <pre><code class="hljs scala" data-trim>
                ...

                  R => Either[E, A]

                  // Given an input R,
                  // the computation either returns an Error or a result A.
                ...
            </code></pre>
            </div>
        </section>
        <section>
                     <pre><code class="hljs scala">
                ...

                  sealed trait FeatureGen[D, Expr, A]

                ...
            </code></pre>
        </section>
        <section>
                        <pre><code class="hljs scala" style="font-size:19px">
                ...

final case class CreateFeatures[D, Expr](input: FeatureDef[D, Expr]) extends FeatureGen[D, Expr, FeatureRes[D]]
              ...

            </code></pre>
        </section>

        <section>
            <pre><code class="hljs scala">
def findRequests(
  x: FeatureGen[D, Expr, B]
 ): List[SMap[Source[D], List[Logic[Expr]]]] = ???
            </code></pre>
        </section>

        <section>
            <pre><code class="hljs scala" style="font-size:19px">
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
    fa match {
      case CreateFeatures(featureDef) => ???
      case JoinFeatures(f1, f2) => ???
      case Pure(_)              => ???
      case Map(f1, _)           => ???
      case Zip(f1, f2)          => ???
      case Fail(_)              => ???
    }
}
            </code></pre>
        </section>

        <section data-transition="fade-out">
            <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="7,8,9" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}

            </code></pre>
        </section>
        <section data-transition="fade-in">
            <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="9,10" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
      </code></pre>
        </section>

        <section data-transition="fade-out">
            <pre><code class="hljs scala"  style="font-size:19px" data-trim data-line-numbers="11" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}

            </code></pre>
        </section>

        <section data-transition="fade-in">
            <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="12" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
        </section>

        <section data-transition="fade-out">
            <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="13" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
        </section>

        <section data-transition="fade-in">
            <pre><code class="hljs scala" style="font-size:19px" data-trim data-line-numbers="14" data-noescape>
def listOfFeatureRequests[D, Expr, A](fa: FeatureGen[D, Expr, A]): List[SMap[Source[D], List[Logic[Expr]]]] = {
  def loop[B](
     value: FeatureGen[D, Expr, B],
     acc: List[SMap[Source[D], List[Logic[Expr]]]]
   ): List[SMap[Source[D], List[Logic[Expr]]]] =
    value match {
      case CreateFeatures(featureDef) =>
        Map(Source(featureDef.input, featureDef.forPartition) -> featureDef.featuresLogic) :: acc

      case JoinFeatures(f1, f2) => (loop(f1, list) |@| loop(f2, list))(_ |+| _)
      case Pure(_)              => acc
      case Map(f1, _)           => loop(f1, acc)
      case Zip(f1, f2)          => loop(f1, acc) ++ loop(f2, acc)
      case Fail(_)              => acc
    }

  loop(fa, List.empty[SMap[Source[D], List[Logic[Expr]]]])
}
            </code></pre>
        </section>
        
        <section>
            <h3>A typical Data Engineering Workflow.</h3>
            <ul>
                <li>Billions of customer event records</li>
                <li>Find out 1000s of attributes of each customer from their events</li>
                <li>Likewise 1000s of features</li>
                <li>All the way to datascience and ML pipelines.</li>
                <li>Predict customer behavior</li>
            </ul>
        </section>
        <section>
            <h2>We have</h2>
            <ul>
                <li>Spark</li>
                <li>Flink</li>
                <li>Scio</li>
                <li>Beam</li>
                <li>And so on..</li>
            </ul>
        </section>
        <section>
            This talk is going to be sharing a real life experience
            of actually solving this problem to a signifiant extent in 2.5 months of time - 1 resource.
        </section>
        <section>
            Ok, so let's write a query - well, a 1000 of them.
            Let's parameterise the where condition so we could reuse some of the feature defintions.
            We need to join them, hence we take each result and join.
            Next time we have feature, we either reuse the defintion or add a new one, and join with the rest.
        </section>
        <section>
            <h2>An example</h2>
        </section>
        <section>
            <h2>An example</h2>
            Find out the usage of chrome per customer in last 2 weeks.
            <pre><code class="hljs sql" data-trim>
                ...

                select
                  customer_id,
                  sum(
                    when("browser" == "safari") 1 else 0
                  ) as "browser_safari_count_0-2w",
                group by customer_id
                where
                  time < time_stamp() &&
                  time >= minusDays(time_stamp(), 14)

                ...
           </code></pre>

        </section>
        <section>
            <h2> We need the count of Chrome as well </h2>
            <pre><code class="hljs sql" data-trim>
                ...

                select
                  customer_id,
                  sum(
                    when("browser" == "chrome") 1 else 0
                  ) as "browser_chrome_count_0-2w",
                group by customer_id
                where
                  time < time_stamp() &&
                  time >= minusDays(time_stamp(), 14)

                ...


					    </code></pre>


        </section>
        <section>
            <h3>Can't we squash them into a single query ?</h3>
            <p>Let's assume we have a query engine that supports it.</p>
            <pre><code class="hljs sql" data-trim>
                ...

                select
                  customer_id,
                  sum(
                    when("browser" == "chrome") 1 else 0
                  ) as "browser_chrome_count_0-2w",
                  sum(
                    when("browser" == "safari") 1 else 0
                  ) as "browser_safari_count_0-2w",
                group by customer_id
                where
                  time < time_stamp() &&
                  time >= minusDays(time_stamp(), 14)

                ...

					    </code></pre>

        </section>
        <section>
            <h2>Let's formalise our challenges.</h2>
        </section>
        <section>
            <h3>Challenges.</h3>
            <ul>
                <li>We have dozen of event types - not just 1 event.</li>
                <li>There are 1000s of features from each of these events.</li>
                <li>Features are dependent to each other - either logically or for optimisations</li>
                <li>Add new features.</li>
                <li>Change in existing features.</li>
            </ul>
        </section>
        <section>
            <h3>Challenges continued..</h3>
            <ul>
                <li>Obvious performance considerations</li>
                <li>Scalable number of features</li>
                <li>Constantly increasing time period</li>
                <li>Reducing redundancy</li>
                <li>Windowing</li>
                <li>IO</li>
            </ul>
        </section>
        <section>
            <h3>And Challenges continued..</h3>
            <ul>
                <li>Opt</li>
                <li>Scalable number of features</li>
                <li>Reducing redundancy</li>
                <li>Windowing</li>
                <li>IO</li>
            </ul>
        </section>
        <section>
            <h3>Too late on:</h3>
            <ul>
                <li> Performance</li>
                <li> Correctness</li>
                <li> How can we add new features and functionalities quickly</li>
                <li> Or here</li>
            </ul>
        </section>
        <section>
            <h2>Abstract away.</h2>
            <pre><code class="hljs scala" data-trim>
						sealed trait FeatureEngineeringWorkflow[D, C, A]

						object {
						  case class ReadData[D]() extends FeatureEngineeringWorkflow[D]
						}

					    </code></pre>
            <p>Trying out :) </p>
        </section>
    </div>
</div>

<script src="js/reveal.js"></script>

<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				// ...

	            // The "normal" size of the presentation, aspect ratio will be preserved
	            // when the presentation is scaled to fit different resolutions. Can be
	            // specified using percentage units.
	            width: 1300,
	            height: 750,

	            // Factor of the display size that should remain empty around the content
	            margin: 0.1,

	            // Bounds for smallest/largest possible scale to apply to content
	            minScale: 0.2,
	            maxScale: 1.5,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});






</script>
</body>
</html>
